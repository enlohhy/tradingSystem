<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ å¯†è´§å¸æ™ºèƒ½ç›‘æµ‹ç³»ç»Ÿ - ä¸“ä¸šäº¤æ˜“åˆ†æå¹³å°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0b0e11;
            --bg-secondary: #161a1e;
            --bg-tertiary: #1e2329;
            --bg-card: #1e2329;
            --text-primary: #eaecef;
            --text-secondary: #848e9c;
            --text-tertiary: #5e6673;
            --border-color: #2b3139;
            --green: #0ecb81;
            --red: #f6465d;
            --yellow: #fcd535;
            --blue: #3861fb;
            --accent: #3861fb;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .navbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo::before {
            content: "ğŸ“Š";
            -webkit-text-fill-color: initial;
        }

        .nav-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: #2f4fd8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(56, 97, 251, 0.4);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-card);
            border-color: var(--text-tertiary);
        }

        .btn-success {
            background: var(--green);
            color: var(--bg-primary);
        }

        .btn-success:hover {
            background: #0db872;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 13px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--green);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: var(--red);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ä¸»å¸ƒå±€ */
        .main-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 0;
            height: calc(100vh - 60px);
        }

        /* ä¾§è¾¹æ  */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-section {
            padding: 0 20px;
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 12px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .coin-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .coin-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .coin-item:hover {
            background: var(--bg-card);
            transform: translateX(4px);
        }

        .coin-item.active {
            border-color: var(--accent);
            background: rgba(56, 97, 251, 0.1);
        }

        .coin-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .coin-symbol {
            font-weight: 600;
            font-size: 15px;
        }

        .coin-price {
            font-size: 14px;
            font-weight: 600;
        }

        .coin-change {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .coin-change.positive {
            color: var(--green);
            background: rgba(14, 203, 129, 0.1);
        }

        .coin-change.negative {
            color: var(--red);
            background: rgba(246, 70, 93, 0.1);
        }

        /* ä¸»å†…å®¹åŒº */
        .content {
            overflow-y: auto;
            padding: 20px;
        }

        /* ä»·æ ¼å¡ç‰‡ */
        .price-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 20px rgba(56, 97, 251, 0.15);
            transform: translateY(-2px);
        }

        .card-title {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .card-value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .card-subtitle {
            font-size: 13px;
            color: var(--text-tertiary);
        }

        /* Kçº¿å›¾åŒºåŸŸ */
        .chart-section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
        }

        .tab-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .tab-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        #chartCanvas {
            width: 100%;
            height: 400px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* æŠ€æœ¯æŒ‡æ ‡é¢æ¿ */
        .indicators-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .indicator-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .indicator-name {
            font-size: 16px;
            font-weight: 600;
        }

        .indicator-signal {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .indicator-signal.buy {
            background: rgba(14, 203, 129, 0.2);
            color: var(--green);
        }

        .indicator-signal.sell {
            background: rgba(246, 70, 93, 0.2);
            color: var(--red);
        }

        .indicator-signal.neutral {
            background: rgba(252, 213, 53, 0.2);
            color: var(--yellow);
        }

        .indicator-details {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .indicator-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .indicator-label {
            color: var(--text-secondary);
        }

        .indicator-value {
            font-weight: 600;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        /* äº¤æ˜“å»ºè®®é¢æ¿ */
        .recommendation-section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .recommendation-title {
            font-size: 20px;
            font-weight: 700;
        }

        .score-badge {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: 700;
        }

        .score-badge.high {
            background: rgba(14, 203, 129, 0.2);
            color: var(--green);
        }

        .score-badge.medium {
            background: rgba(252, 213, 53, 0.2);
            color: var(--yellow);
        }

        .score-badge.low {
            background: rgba(246, 70, 93, 0.2);
            color: var(--red);
        }

        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .recommendation-item {
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .recommendation-item-title {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .recommendation-item-value {
            font-size: 18px;
            font-weight: 600;
        }

        .prediction-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .prediction-row:last-child {
            border-bottom: none;
        }

        /* é£é™©æç¤º */
        .risk-warning {
            background: rgba(246, 70, 93, 0.1);
            border: 1px solid rgba(246, 70, 93, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .risk-warning-title {
            color: var(--red);
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .risk-warning-content {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ç§»åŠ¨ç«¯èœå•æŒ‰é’® */
        .mobile-menu-btn {
            display: none;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .mobile-menu-btn:hover {
            background: var(--bg-card);
            border-color: var(--text-tertiary);
        }

        .mobile-menu-btn:active {
            transform: scale(0.95);
        }

        /* ä¾§è¾¹æ é®ç½© */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.show {
            display: block;
            opacity: 1;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: fixed;
                left: -280px;
                top: 60px;
                width: 280px;
                height: calc(100vh - 60px);
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
            }

            .sidebar.show {
                left: 0;
            }

            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .logo {
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0 12px;
                height: 56px;
            }

            .logo {
                font-size: 16px;
            }

            .price-cards {
                grid-template-columns: 1fr;
            }

            .content {
                padding: 12px;
            }

            .nav-controls {
                gap: 6px;
                flex-wrap: nowrap;
                overflow-x: auto;
            }

            .nav-controls .btn {
                white-space: nowrap;
                flex-shrink: 0;
            }

            .btn {
                padding: 6px 10px;
                font-size: 12px;
            }

            .status-indicator {
                display: none;
            }

            .sidebar {
                top: 56px;
                height: calc(100vh - 56px);
            }
        }

        @media (max-width: 480px) {
            .nav-controls .btn span {
                display: none;
            }

            .btn {
                padding: 8px;
                min-width: 36px;
                justify-content: center;
            }

            .logo::before {
                margin-right: -4px;
            }

            .modal {
                width: 95%;
                padding: 20px 16px;
                max-height: 85vh;
            }

            .modal-header h2 {
                font-size: 18px;
            }

            .card {
                padding: 16px;
            }

            .card-title {
                font-size: 12px;
            }

            .card-value {
                font-size: 20px;
            }

            .sidebar {
                width: 100%;
                left: -100%;
            }

            .sidebar.show {
                left: 0;
            }

            .resonance-grid {
                grid-template-columns: 1fr;
            }

            .add-coin-input {
                font-size: 14px;
            }

            .section-title {
                font-size: 16px;
                margin-bottom: 12px;
            }

            .indicator-card,
            .theory-analysis {
                padding: 12px;
            }

            .theory-title,
            .indicator-title {
                font-size: 14px;
            }

            .theory-content,
            .indicator-value {
                font-size: 13px;
            }

            .coin-item {
                padding: 10px;
                font-size: 14px;
            }

            .btn-add {
                font-size: 13px;
                padding: 10px;
            }

            .timeframe-btn {
                font-size: 12px;
                padding: 6px 10px;
            }

            .trade-action {
                font-size: 16px;
                padding: 12px;
            }

            .confidence-bar {
                height: 6px;
            }
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-color);
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 16px;
        }

        /* æ¨¡æ€æ¡† */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: transparent;
            border: none;
            font-size: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-section {
            margin-bottom: 24px;
        }

        .modal-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .checkbox-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
        }

        .checkbox-item.checked {
            border-color: var(--accent);
            background: rgba(56, 97, 251, 0.1);
        }

        .checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .checkbox-label {
            flex: 1;
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        .checkbox-label-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .checkbox-label-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        /* å…±æŒ¯åˆ†ææ ·å¼ */
        .resonance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .resonance-item {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .resonance-item.bullish {
            border-color: var(--green);
            background: linear-gradient(135deg, rgba(14, 203, 129, 0.1) 0%, var(--bg-secondary) 100%);
        }

        .resonance-item.bearish {
            border-color: var(--red);
            background: linear-gradient(135deg, rgba(246, 70, 93, 0.1) 0%, var(--bg-secondary) 100%);
        }

        .resonance-item.neutral {
            border-color: var(--yellow);
            background: linear-gradient(135deg, rgba(252, 213, 53, 0.1) 0%, var(--bg-secondary) 100%);
        }

        .resonance-timeframe {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .resonance-trend {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .resonance-strength {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .resonance-summary {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
        }

        .resonance-score {
            font-size: 32px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .golden-point {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }

        .golden-point.buy {
            background: var(--green);
            box-shadow: 0 0 10px rgba(14, 203, 129, 0.8);
        }

        .golden-point.sell {
            background: var(--red);
            box-shadow: 0 0 10px rgba(246, 70, 93, 0.8);
        }

        .golden-point:hover {
            transform: translate(-50%, -50%) scale(1.3);
        }

        .risk-reward-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            margin-top: 16px;
        }

        .risk-reward-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .risk-reward-item {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: 6px;
        }

        .risk-reward-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .risk-reward-value {
            font-size: 20px;
            font-weight: bold;
        }

        .position-advice {
            background: linear-gradient(135deg, rgba(56, 97, 251, 0.1) 0%, transparent 100%);
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            margin-top: 16px;
        }

        /* æ·»åŠ å¸ç§è¾“å…¥æ¡† */
        .add-coin-form {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .add-coin-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 8px;
            transition: all 0.3s;
        }

        .add-coin-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(56, 97, 251, 0.1);
        }

        .add-coin-input::placeholder {
            color: var(--text-tertiary);
        }

        .btn-add {
            width: 100%;
            padding: 8px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-add:hover {
            background: #2f4fd8;
            transform: translateY(-1px);
        }

        /* å¸‚åœºæ‰«æç»“æœ */
        .scan-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
            padding: 20px;
        }

        .scan-content {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 24px;
        }

        .scan-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .scan-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .scan-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .scan-item {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }

        .scan-item:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .scan-item.buy-signal {
            border-left: 4px solid var(--green);
        }

        .scan-item.sell-signal {
            border-left: 4px solid var(--red);
        }

        .scan-symbol {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .scan-signal {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .scan-signal.buy {
            background: rgba(14, 203, 129, 0.2);
            color: var(--green);
        }

        .scan-signal.sell {
            background: rgba(246, 70, 93, 0.2);
            color: var(--red);
        }

        .scan-details {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <nav class="navbar">
        <div style="display: flex; align-items: center; gap: 12px;">
            <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="toggleSidebar()">
                â˜°
            </button>
            <div class="logo">åŠ å¯†è´§å¸æ™ºèƒ½ç›‘æµ‹ç³»ç»Ÿ</div>
        </div>
        <div class="nav-controls">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">è¿æ¥ä¸­...</span>
            </div>
            <button class="btn btn-secondary" id="refreshBtn" onclick="manualRefresh()">
                ğŸ”„ <span>åˆ·æ–°</span>
            </button>
            <button class="btn btn-primary" id="analyzeBtn" onclick="showAnalysisOptions()">
                ğŸ“Š <span>æŠ€æœ¯åˆ†æ</span>
            </button>
            <button class="btn btn-primary" id="scanBtn" onclick="scanMarketOpportunities()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                ğŸ” <span>æ‰«æå¸‚åœº</span>
            </button>
            <button class="btn btn-success" id="toggleBtn" onclick="toggleMode()">
                â¸ï¸ <span>æš‚åœ</span>
            </button>
        </div>
    </nav>

    <!-- ä¾§è¾¹æ é®ç½©å±‚ -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

    <!-- ä¸»å®¹å™¨ -->
    <div class="main-container">
        <!-- ä¾§è¾¹æ  -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">æ·»åŠ å¸ç§</div>
                <div class="add-coin-form">
                    <input 
                        type="text" 
                        id="coinInput" 
                        class="add-coin-input" 
                        placeholder="è¾“å…¥å¸ç§ç¬¦å·ï¼ˆå¦‚ï¼šETHUSDTï¼‰"
                        onkeypress="handleCoinInputEnter(event)"
                    />
                    <button class="btn-add" onclick="addCustomCoin()">
                        â• æ·»åŠ å¸ç§
                    </button>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">ç›‘æ§å¸ç§</div>
                <div class="coin-list" id="coinList">
                    <!-- å¸ç§åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </aside>

        <!-- ä¸»å†…å®¹åŒº -->
        <main class="content">
            <!-- ä»·æ ¼å¡ç‰‡ -->
            <div class="price-cards" id="priceCards">
                <div class="card">
                    <div class="card-title">å½“å‰ä»·æ ¼</div>
                    <div class="card-value" id="currentPrice">-</div>
                    <div class="card-subtitle">é€‰æ‹©å¸ç§æŸ¥çœ‹ä»·æ ¼</div>
                </div>
                <div class="card">
                    <div class="card-title">24å°æ—¶æ¶¨è·Œ</div>
                    <div class="card-value" id="priceChange">-</div>
                    <div class="card-subtitle">24å°æ—¶å˜åŒ–å¹…åº¦</div>
                </div>
                <div class="card">
                    <div class="card-title">24å°æ—¶æœ€é«˜</div>
                    <div class="card-value" id="high24h">-</div>
                    <div class="card-subtitle">24å°æ—¶å†…æœ€é«˜ä»·</div>
                </div>
                <div class="card">
                    <div class="card-title">24å°æ—¶æœ€ä½</div>
                    <div class="card-value" id="low24h">-</div>
                    <div class="card-subtitle">24å°æ—¶å†…æœ€ä½ä»·</div>
                </div>
            </div>

            <!-- Kçº¿å›¾ -->
            <div class="chart-section">
                <div class="chart-header">
                    <div class="chart-title">ä»·æ ¼èµ°åŠ¿å›¾</div>
                    <div class="chart-controls">
                        <button class="tab-btn" onclick="changeTimeframe('5m', event)">5åˆ†é’Ÿ</button>
                        <button class="tab-btn" onclick="changeTimeframe('15m', event)">15åˆ†é’Ÿ</button>
                        <button class="tab-btn active" onclick="changeTimeframe('1h', event)">1å°æ—¶</button>
                        <button class="tab-btn" onclick="changeTimeframe('4h', event)">4å°æ—¶</button>
                        <button class="tab-btn" onclick="changeTimeframe('1d', event)">1å¤©</button>
                    </div>
                </div>
                <canvas id="chartCanvas"></canvas>
            </div>

            <!-- å¤šå‘¨æœŸå…±æŒ¯åˆ†æ -->
            <div class="chart-section" id="resonanceSection" style="display: none; margin-top: 16px;">
                <div class="chart-header">
                    <div class="chart-title">ğŸ¯ å¤šå‘¨æœŸå…±æŒ¯åˆ†æ</div>
                </div>
                <div id="resonanceContent" style="padding: 16px;">
                    <!-- å…±æŒ¯åˆ†æå†…å®¹å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- æŠ€æœ¯æŒ‡æ ‡ -->
            <div class="indicators-section" id="indicatorsSection">
                <!-- æŠ€æœ¯æŒ‡æ ‡å¡ç‰‡å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>

            <!-- äº¤æ˜“å»ºè®® -->
            <div class="recommendation-section" id="recommendationSection" style="display: none;">
                <!-- äº¤æ˜“å»ºè®®å†…å®¹å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </main>
    </div>

    <!-- æŠ€æœ¯åˆ†æé€‰é¡¹æ¨¡æ€æ¡† -->
    <div class="modal-overlay" id="analysisModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">ğŸ“Š é€‰æ‹©åˆ†ææ–¹æ³•</div>
                <button class="modal-close" onclick="closeAnalysisModal()">Ã—</button>
            </div>
            
            <div class="modal-section">
                <div class="modal-section-title">äº¤æ˜“ç†è®ºï¼ˆå¯é€‰ï¼‰</div>
                <div class="checkbox-group">
                    <label class="checkbox-item" onclick="toggleCheckbox(this, 'fibonacci')">
                        <input type="checkbox" id="check-fibonacci" checked>
                        <div class="checkbox-label">
                            <div class="checkbox-label-title">ğŸ“ æ–æ³¢é‚£å¥‘åˆ†æ</div>
                            <div class="checkbox-label-desc">è¯†åˆ«å…³é”®æ”¯æ’‘é˜»åŠ›ä½</div>
                        </div>
                    </label>
                    
                    <label class="checkbox-item" onclick="toggleCheckbox(this, 'elliott')">
                        <input type="checkbox" id="check-elliott" checked>
                        <div class="checkbox-label">
                            <div class="checkbox-label-title">ğŸŒŠ æ³¢æµªç†è®º</div>
                            <div class="checkbox-label-desc">åˆ†æå¸‚åœºå‘¨æœŸå’Œè¶‹åŠ¿</div>
                        </div>
                    </label>
                    
                    <label class="checkbox-item" onclick="toggleCheckbox(this, 'chan')">
                        <input type="checkbox" id="check-chan" checked>
                        <div class="checkbox-label">
                            <div class="checkbox-label-title">ğŸ“ˆ ç¼ è®º</div>
                            <div class="checkbox-label-desc">è¯†åˆ«ç²¾å‡†ä¹°å–ç‚¹</div>
                        </div>
                    </label>
                    
                    <label class="checkbox-item" onclick="toggleCheckbox(this, 'wyckoff')">
                        <input type="checkbox" id="check-wyckoff" checked>
                        <div class="checkbox-label">
                            <div class="checkbox-label-title">ğŸ“Š å¨ç§‘å¤«äº¤æ˜“æ³•</div>
                            <div class="checkbox-label-desc">åˆ†æä¸»åŠ›è¡Œä¸ºå’Œä¾›éœ€</div>
                        </div>
                    </label>
                </div>
            </div>
            
            <div style="padding: 12px; background: rgba(56, 97, 251, 0.1); border-radius: 8px; margin-bottom: 16px;">
                <div style="font-size: 13px; color: var(--text-secondary);">
                    ğŸ’¡ æç¤ºï¼šæŠ€æœ¯æŒ‡æ ‡ï¼ˆMAã€MACDã€RSIã€BOLLã€KDJã€VOLï¼‰å§‹ç»ˆåŒ…å«åœ¨åˆ†æä¸­
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeAnalysisModal()">å–æ¶ˆ</button>
                <button class="btn btn-primary" onclick="startAnalysis()">å¼€å§‹åˆ†æ</button>
            </div>
        </div>
    </div>

    <!-- å¸‚åœºæ‰«ææ¨¡æ€æ¡† -->
    <div class="scan-modal" id="scanModal">
        <div class="scan-content">
            <div class="scan-header">
                <div class="scan-title">ğŸ” å¸‚åœºæœºä¼šæ‰«æ</div>
                <button class="modal-close" onclick="closeScanModal()">Ã—</button>
            </div>
            <div id="scanProgress" style="display: none; text-align: center; padding: 40px;">
                <div class="loading-spinner" style="width: 40px; height: 40px; border-width: 4px; margin: 0 auto 16px;"></div>
                <div style="font-size: 16px; color: var(--text-primary); margin-bottom: 8px;">æ­£åœ¨æ‰«æå¸‚åœº...</div>
                <div id="scanProgressText" style="font-size: 14px; color: var(--text-secondary);">å·²æ‰«æ: 0/0</div>
            </div>
            <div id="scanResults">
                <!-- æ‰«æç»“æœå°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let ws = null;
        let isConnected = false;
        let realtimeMode = true;
        let currentSymbol = 'BTC';
        let currentTimeframe = '1h';
        let priceData = {};
        let klineData = {};
        let chartInstance = null;
        let resonanceResult = null; // å­˜å‚¨å¤šå‘¨æœŸå…±æŒ¯åˆ†æç»“æœ

        // å¸ç§é…ç½®ï¼ˆæ”¹ä¸º let ä»¥æ”¯æŒåŠ¨æ€æ·»åŠ ï¼‰
        let SYMBOLS = ['BTC', 'ETH', 'SOL', 'DOGE', 'BNB'];
        let SYMBOL_MAP = {
            'BTC': 'BTCUSDT',
            'ETH': 'ETHUSDT',
            'SOL': 'SOLUSDT',
            'DOGE': 'DOGEUSDT',
            'BNB': 'BNBUSDT'
        };

        // ==================== WebSocket è¿æ¥ ====================
        function connectWebSocket() {
            const streams = SYMBOLS.map(s => `${SYMBOL_MAP[s].toLowerCase()}@ticker`).join('/');
            const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                isConnected = true;
                updateStatus(true);
                console.log('WebSocket è¿æ¥æˆåŠŸ');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.data && data.data.e === '24hrTicker') {
                    updatePriceData(data.data);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket é”™è¯¯:', error);
                updateStatus(false);
            };

            ws.onclose = () => {
                isConnected = false;
                updateStatus(false);
                console.log('WebSocket è¿æ¥æ–­å¼€');
                if (realtimeMode) {
                    setTimeout(connectWebSocket, 5000);
                }
            };
        }

        // ==================== æ•°æ®æ›´æ–° ====================
        function updatePriceData(ticker) {
            const symbol = ticker.s.replace('USDT', '');
            const data = {
                symbol: symbol,
                price: parseFloat(ticker.c),
                change: parseFloat(ticker.P),
                high: parseFloat(ticker.h),
                low: parseFloat(ticker.l),
                volume: parseFloat(ticker.q)
            };

            priceData[symbol] = data;
            updateCoinList();
            
            if (symbol === currentSymbol) {
                updatePriceCards(data);
                
                // å®æ—¶æ›´æ–°Kçº¿å›¾ï¼ˆå¦‚æœæœ‰Kçº¿æ•°æ®ï¼‰
                if (klineData[symbol] && klineData[symbol].length > 0) {
                    drawChart(klineData[symbol]);
                }
            }
        }

        // ==================== UI æ›´æ–° ====================
        function updateStatus(connected) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.remove('disconnected');
                statusText.textContent = realtimeMode ? 'å®æ—¶æ¨é€ä¸­' : 'å·²æš‚åœ';
            } else {
                statusDot.classList.add('disconnected');
                statusText.textContent = 'è¿æ¥æ–­å¼€';
            }
        }

        function updateCoinList() {
            const coinList = document.getElementById('coinList');
            coinList.innerHTML = '';

            SYMBOLS.forEach(symbol => {
                const data = priceData[symbol] || { price: 0, change: 0 };
                const isPositive = data.change >= 0;

                const coinItem = document.createElement('div');
                coinItem.className = `coin-item ${symbol === currentSymbol ? 'active' : ''}`;
                coinItem.onclick = () => selectCoin(symbol);
                coinItem.innerHTML = `
                    <div class="coin-item-header">
                        <span class="coin-symbol">${symbol}</span>
                        <span class="coin-change ${isPositive ? 'positive' : 'negative'}">
                            ${isPositive ? 'â–²' : 'â–¼'} ${Math.abs(data.change).toFixed(2)}%
                        </span>
                    </div>
                    <div class="coin-price">$${formatPrice(data.price)}</div>
                `;
                coinList.appendChild(coinItem);
            });
        }

        function updatePriceCards(data) {
            const isPositive = data.change >= 0;
            
            document.getElementById('currentPrice').textContent = `$${formatPrice(data.price)}`;
            document.getElementById('currentPrice').style.color = 'var(--text-primary)';
            
            const changeEl = document.getElementById('priceChange');
            changeEl.textContent = `${isPositive ? 'â–²' : 'â–¼'} ${data.change.toFixed(2)}%`;
            changeEl.style.color = isPositive ? 'var(--green)' : 'var(--red)';
            
            document.getElementById('high24h').textContent = `$${formatPrice(data.high)}`;
            document.getElementById('high24h').style.color = 'var(--green)';
            
            document.getElementById('low24h').textContent = `$${formatPrice(data.low)}`;
            document.getElementById('low24h').style.color = 'var(--red)';
        }

        function selectCoin(symbol) {
            currentSymbol = symbol;
            updateCoinList();
            
            if (priceData[symbol]) {
                updatePriceCards(priceData[symbol]);
            }
            
            // æ¸…ç©ºä¹‹å‰çš„åˆ†ææ•°æ®
            clearAnalysisResults();
            
            loadKlineData(symbol, currentTimeframe);
            
            // åœ¨ç§»åŠ¨ç«¯é€‰æ‹©å¸ç§åè‡ªåŠ¨å…³é—­ä¾§è¾¹æ 
            if (window.innerWidth <= 1024) {
                closeSidebar();
            }
        }

        function clearAnalysisResults() {
            // æ¸…ç©ºæŠ€æœ¯æŒ‡æ ‡åŒºåŸŸ
            const indicatorsSection = document.getElementById('indicatorsSection');
            indicatorsSection.innerHTML = '';
            
            // éšè—äº¤æ˜“å»ºè®®åŒºåŸŸ
            const recommendationSection = document.getElementById('recommendationSection');
            recommendationSection.style.display = 'none';
            recommendationSection.innerHTML = '';
        }

        // ==================== Kçº¿æ•°æ®åŠ è½½ ====================
        async function loadKlineData(symbol, timeframe) {
            const tradingPair = SYMBOL_MAP[symbol];
            const limit = 100;
            const url = `https://api.binance.com/api/v3/klines?symbol=${tradingPair}&interval=${timeframe}&limit=${limit}`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                
                klineData[symbol] = data.map(k => ({
                    time: k[0],
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                }));

                drawChart(klineData[symbol]);
            } catch (error) {
                console.error('åŠ è½½Kçº¿æ•°æ®å¤±è´¥:', error);
            }
        }

        // ==================== å›¾è¡¨ç»˜åˆ¶ ====================
        function drawChart(data) {
            if (!data || data.length === 0) return;

            const canvas = document.getElementById('chartCanvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®canvaså°ºå¯¸
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // è®¡ç®—ä»·æ ¼èŒƒå›´
            const prices = data.map(d => [d.high, d.low]).flat();
            const maxPrice = Math.max(...prices);
            const minPrice = Math.min(...prices);
            const priceRange = maxPrice - minPrice;

            // ç»˜åˆ¶å‚æ•°
            const padding = 60;
            const chartWidth = canvas.width - padding * 2;
            const chartHeight = canvas.height - padding * 2;
            const barWidth = chartWidth / data.length;

            // ç»˜åˆ¶Kçº¿
            data.forEach((candle, index) => {
                const x = padding + index * barWidth + barWidth / 2;
                const openY = padding + (maxPrice - candle.open) / priceRange * chartHeight;
                const closeY = padding + (maxPrice - candle.close) / priceRange * chartHeight;
                const highY = padding + (maxPrice - candle.high) / priceRange * chartHeight;
                const lowY = padding + (maxPrice - candle.low) / priceRange * chartHeight;

                const isGreen = candle.close >= candle.open;
                ctx.fillStyle = isGreen ? '#0ecb81' : '#f6465d';
                ctx.strokeStyle = isGreen ? '#0ecb81' : '#f6465d';

                // ç»˜åˆ¶ä¸Šä¸‹å½±çº¿
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.lineWidth = 1;
                ctx.stroke();

                // ç»˜åˆ¶å®ä½“
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(closeY - openY);
                ctx.fillRect(x - barWidth / 4, bodyTop, barWidth / 2, bodyHeight || 1);
            });

            // ç»˜åˆ¶ä»·æ ¼æ ‡ç­¾ï¼ˆå·¦ä¾§ï¼‰- ä½¿ç”¨æ›´ç²¾ç¡®çš„å°æ•°ä½
            ctx.fillStyle = '#848e9c';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(formatPriceForChart(maxPrice), padding - 5, padding);
            ctx.textBaseline = 'bottom';
            ctx.fillText(formatPriceForChart(minPrice), padding - 5, canvas.height - padding);
        }

        // å›¾è¡¨ä¸“ç”¨ä»·æ ¼æ ¼å¼åŒ–ï¼ˆæ›´å¤šå°æ•°ä½ï¼‰
        function formatPriceForChart(price) {
            if (price < 0.01) return price.toFixed(8);
            if (price < 1) return price.toFixed(6);
            if (price < 100) return price.toFixed(4);
            return price.toFixed(2);
        }

        // ==================== æŠ€æœ¯åˆ†æ ====================
        async function performAnalysis() {
            if (!klineData[currentSymbol] || klineData[currentSymbol].length < 30) {
                alert('æ•°æ®ä¸è¶³ï¼Œè¯·å…ˆé€‰æ‹©å¸ç§å¹¶ç­‰å¾…æ•°æ®åŠ è½½');
                return;
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const section = document.getElementById('recommendationSection');
            section.style.display = 'block';
            section.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

            // 1. æ‰§è¡Œå¤šå‘¨æœŸå…±æŒ¯åˆ†æ
            await performMultiTimeframeAnalysis();

            const data = klineData[currentSymbol];
            const closes = data.map(d => d.close);
            const highs = data.map(d => d.high);
            const lows = data.map(d => d.low);
            const volumes = data.map(d => d.volume);
            const currentPrice = closes[closes.length - 1];

            // è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
            const indicators = {
                MA: calculateMA(closes),
                MACD: calculateMACD(closes),
                RSI: calculateRSI(closes),
                BOLL: calculateBOLL(closes),
                KDJ: calculateKDJ(highs, lows, closes),
                VOL: calculateVOL(volumes)
            };

            // è·å–é€‰æ‹©çš„ç†è®º
            const selectedTheories = getSelectedTheories();

            // æ ¹æ®é€‰æ‹©è®¡ç®—äº¤æ˜“ç†è®º
            let fibonacci = null, elliottWave = null, chanTheory = null, wyckoff = null;
            
            if (selectedTheories.fibonacci) {
                fibonacci = calculateFibonacci(highs, lows, currentPrice);
            }
            if (selectedTheories.elliott) {
                // ä¼ é€’å®Œæ•´å‚æ•°ç”¨äºä¸“ä¸šæ³¢æµªåˆ†æ
                const macdHistogram = indicators.MACD.histogram;
                const rsiValues = [indicators.RSI.rsi];
                elliottWave = analyzeElliottWave(closes, highs, lows, volumes, macdHistogram, rsiValues);
            }
            if (selectedTheories.chan) {
                // æå–MACDç›´æ–¹å›¾ç”¨äºèƒŒé©°æ£€æµ‹
                const macdHistogram = indicators.MACD.histogram;
                chanTheory = analyzeChanTheory(highs, lows, closes, macdHistogram);
            }
            if (selectedTheories.wyckoff) {
                wyckoff = analyzeWyckoff(closes, volumes, highs, lows);
            }

            displayIndicators(indicators);
            
            // ç”Ÿæˆç»¼åˆäº¤æ˜“å»ºè®®
            const recommendation = generateComprehensiveRecommendation(
                indicators, 
                fibonacci, 
                elliottWave, 
                chanTheory, 
                wyckoff, 
                currentPrice,
                currentTimeframe
            );
            
            // 2. è¯†åˆ«é»„é‡‘ä¹°å–ç‚¹
            const goldenPoints = identifyGoldenPoints(data, indicators, fibonacci, elliottWave, chanTheory, wyckoff);
            
            // 3. è®¡ç®—é£é™©æ”¶ç›Šæ¯”
            const riskReward = calculateRiskReward(currentPrice, recommendation);
            
            // 4. æ£€æµ‹åˆ†æ­§å¹¶è®¡ç®—ä¿¡å·ä¸€è‡´æ€§
            const divergenceAnalysis = detectDivergence(recommendation);
            
            // æ˜¾ç¤ºåˆ†æç»“æœ
            displayComprehensiveRecommendation(recommendation, indicators, fibonacci, elliottWave, chanTheory, wyckoff, riskReward, goldenPoints, divergenceAnalysis);
        }

        // ==================== å¤šå‘¨æœŸå…±æŒ¯åˆ†æ ====================
        async function performMultiTimeframeAnalysis() {
            const timeframes = ['5m', '15m', '1h', '4h', '1d'];
            const results = [];
            
            // åŠ è½½æ‰€æœ‰å‘¨æœŸçš„æ•°æ®
            for (const tf of timeframes) {
                try {
                    // è·å–å®Œæ•´çš„äº¤æ˜“å¯¹ç¬¦å·ï¼ˆå¦‚ BTCUSDTï¼‰
                    const fullSymbol = SYMBOL_MAP[currentSymbol] || currentSymbol + 'USDT';
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${fullSymbol}&interval=${tf}&limit=100`);
                    const data = await response.json();
                    
                    const klines = data.map(k => ({
                        time: k[0],
                        open: parseFloat(k[1]),
                        high: parseFloat(k[2]),
                        low: parseFloat(k[3]),
                        close: parseFloat(k[4]),
                        volume: parseFloat(k[5])
                    }));
                    
                    // å¿«é€Ÿåˆ†æè¯¥å‘¨æœŸçš„è¶‹åŠ¿ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
                    const closes = klines.map(k => k.close);
                    const highs = klines.map(k => k.high);
                    const lows = klines.map(k => k.low);
                    const volumes = klines.map(k => k.volume);
                    
                    const ma7 = closes.slice(-7).reduce((a, b) => a + b, 0) / 7;
                    const ma30 = closes.slice(-30).reduce((a, b) => a + b, 0) / 30;
                    const ma60 = closes.slice(-60).reduce((a, b) => a + b, 0) / 60;
                    const currentPrice = closes[closes.length - 1];
                    const priceChange = ((currentPrice - closes[closes.length - 20]) / closes[closes.length - 20]) * 100;
                    
                    // è®¡ç®—RSI
                    const rsi = calculateRSI(closes, 14);
                    
                    // è®¡ç®—æˆäº¤é‡è¶‹åŠ¿
                    const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
                    const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
                    const volumeRatio = recentVolume / avgVolume;
                    
                    // åˆ¤æ–­è¶‹åŠ¿ï¼ˆå¤šæ¡ä»¶ç»¼åˆï¼‰
                    let trend = 'neutral';
                    let strength = 0;
                    let signals = [];
                    
                    // å‡çº¿æ’åˆ—
                    const bullishMA = currentPrice > ma7 && ma7 > ma30 && ma30 > ma60;
                    const bearishMA = currentPrice < ma7 && ma7 < ma30 && ma30 < ma60;
                    
                    // RSIç¡®è®¤ï¼ˆå¸åœˆæ ‡å‡†ï¼šè¶…ä¹°>80ï¼Œè¶…å–<20ï¼‰
                    const rsiOversold = rsi < 20;
                    const rsiOverbought = rsi > 80;
                    const rsiNeutral = rsi >= 20 && rsi <= 80;
                    
                    // æˆäº¤é‡ç¡®è®¤
                    const volumeStrong = volumeRatio > 1.2;
                    const volumeWeak = volumeRatio < 0.8;
                    
                    if (bullishMA && !rsiOverbought && volumeStrong) {
                        trend = 'bullish';
                        strength = Math.min(Math.abs(priceChange) * 10 + 20, 100);
                        signals.push('å‡çº¿å¤šå¤´', 'é‡èƒ½é…åˆ');
                    } else if (bullishMA && !rsiOverbought) {
                        trend = 'bullish';
                        strength = Math.min(Math.abs(priceChange) * 10, 80);
                        signals.push('å‡çº¿å¤šå¤´');
                    } else if (bearishMA && !rsiOversold && volumeStrong) {
                        trend = 'bearish';
                        strength = Math.min(Math.abs(priceChange) * 10 + 20, 100);
                        signals.push('å‡çº¿ç©ºå¤´', 'é‡èƒ½é…åˆ');
                    } else if (bearishMA && !rsiOversold) {
                        trend = 'bearish';
                        strength = Math.min(Math.abs(priceChange) * 10, 80);
                        signals.push('å‡çº¿ç©ºå¤´');
                    } else {
                        trend = 'neutral';
                        strength = 50;
                        signals.push('è¶‹åŠ¿ä¸æ˜');
                    }
                    
                    results.push({
                        timeframe: tf,
                        trend,
                        strength: strength.toFixed(0),
                        priceChange: priceChange.toFixed(2),
                        rsi: rsi ? rsi.toFixed(1) : 'N/A',
                        volumeRatio: volumeRatio.toFixed(2),
                        signals: signals.join(', ')
                    });
                } catch (error) {
                    console.error(`åŠ è½½${tf}å‘¨æœŸæ•°æ®å¤±è´¥:`, error);
                }
            }
            
            // è®¡ç®—å…±æŒ¯åº¦
            const bullishCount = results.filter(r => r.trend === 'bullish').length;
            const bearishCount = results.filter(r => r.trend === 'bearish').length;
            const neutralCount = results.filter(r => r.trend === 'neutral').length;
            
            let resonance = 0;
            let resonanceType = 'neutral';
            
            if (bullishCount >= 3) {
                resonance = (bullishCount / results.length) * 100;
                resonanceType = 'bullish';
            } else if (bearishCount >= 3) {
                resonance = (bearishCount / results.length) * 100;
                resonanceType = 'bearish';
            } else {
                resonance = 50;
                resonanceType = 'neutral';
            }
            
            // æ˜¾ç¤ºå…±æŒ¯åˆ†æç»“æœ
            displayResonanceAnalysis(results, resonance, resonanceType);
        }
        
        function displayResonanceAnalysis(results, resonance, resonanceType) {
            // ä¿å­˜å…±æŒ¯ç»“æœåˆ°å…¨å±€å˜é‡
            resonanceResult = { results, resonance, resonanceType };
            
            const section = document.getElementById('resonanceSection');
            const content = document.getElementById('resonanceContent');
            section.style.display = 'block';
            
            const getTrendIcon = (trend) => {
                if (trend === 'bullish') return 'ğŸ“ˆ';
                if (trend === 'bearish') return 'ğŸ“‰';
                return 'â¡ï¸';
            };
            
            const getTrendText = (trend) => {
                if (trend === 'bullish') return 'çœ‹æ¶¨';
                if (trend === 'bearish') return 'çœ‹è·Œ';
                return 'éœ‡è¡';
            };
            
            const getTrendColor = (trend) => {
                if (trend === 'bullish') return 'var(--green)';
                if (trend === 'bearish') return 'var(--red)';
                return 'var(--yellow)';
            };
            
            const getTimeframeName = (tf) => {
                const names = { '5m': '5åˆ†é’Ÿ', '15m': '15åˆ†é’Ÿ', '1h': '1å°æ—¶', '4h': '4å°æ—¶', '1d': '1å¤©' };
                return names[tf] || tf;
            };
            
            let resonanceColor = 'var(--yellow)';
            let resonanceDesc = 'å„å‘¨æœŸè¶‹åŠ¿ä¸ä¸€è‡´ï¼Œå»ºè®®è§‚æœ›';
            
            if (resonanceType === 'bullish') {
                resonanceColor = 'var(--green)';
                resonanceDesc = 'å¤šä¸ªå‘¨æœŸå…±æŒ¯çœ‹æ¶¨ï¼Œä¸Šæ¶¨æ¦‚ç‡è¾ƒé«˜';
            } else if (resonanceType === 'bearish') {
                resonanceColor = 'var(--red)';
                resonanceDesc = 'å¤šä¸ªå‘¨æœŸå…±æŒ¯çœ‹è·Œï¼Œä¸‹è·Œæ¦‚ç‡è¾ƒé«˜';
            }
            
            content.innerHTML = `
                <div class="resonance-summary">
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div>
                            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">å¤šå‘¨æœŸå…±æŒ¯åº¦</div>
                            <div class="resonance-score" style="color: ${resonanceColor}">${resonance.toFixed(0)}%</div>
                            <div style="font-size: 14px; color: var(--text-secondary);">${resonanceDesc}</div>
                        </div>
                        <div style="font-size: 48px;">${getTrendIcon(resonanceType)}</div>
                    </div>
                </div>
                
                <div class="resonance-grid">
                    ${results.map(r => `
                        <div class="resonance-item ${r.trend}">
                            <div class="resonance-timeframe">${getTimeframeName(r.timeframe)}</div>
                            <div class="resonance-trend" style="color: ${getTrendColor(r.trend)}">
                                ${getTrendIcon(r.trend)} ${getTrendText(r.trend)}
                            </div>
                            <div class="resonance-strength">å¼ºåº¦: ${r.strength}%</div>
                            <div class="resonance-strength" style="color: ${parseFloat(r.priceChange) >= 0 ? 'var(--green)' : 'var(--red)'}">
                                æ¶¨è·Œ: ${r.priceChange}%
                            </div>
                            <div class="resonance-strength" style="font-size: 11px; margin-top: 4px;">
                                RSI: ${r.rsi} | é‡æ¯”: ${r.volumeRatio}x
                            </div>
                            <div class="resonance-strength" style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">
                                ${r.signals}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // ==================== é»„é‡‘ä¹°å–ç‚¹è¯†åˆ« ====================
        function identifyGoldenPoints(data, indicators, fibonacci, elliottWave, chanTheory, wyckoff) {
            const points = [];
            const closes = data.map(d => d.close);
            const highs = data.map(d => d.high);
            const lows = data.map(d => d.low);
            const volumes = data.map(d => d.volume);
            
            // éå†æœ€è¿‘20æ ¹Kçº¿ï¼Œå¯»æ‰¾ä¹°å–ç‚¹
            for (let i = Math.max(0, data.length - 20); i < data.length - 1; i++) {
                let buySignals = 0;
                let sellSignals = 0;
                let reasons = [];
                
                // æ£€æŸ¥æŠ€æœ¯æŒ‡æ ‡ä¿¡å·ï¼ˆå¸åœˆRSIæ ‡å‡†ï¼šè¶…ä¹°>80ï¼Œè¶…å–<20ï¼‰
                if (indicators.RSI) {
                    const rsiValue = calculateRSIAtIndex(closes.slice(0, i + 1), 14);
                    if (rsiValue < 20) {
                        buySignals++;
                        reasons.push('RSIè¶…å–');
                    } else if (rsiValue > 80) {
                        sellSignals++;
                        reasons.push('RSIè¶…ä¹°');
                    }
                }
                
                // æ£€æŸ¥MACDé‡‘å‰/æ­»å‰
                if (i > 0) {
                    const macdNow = calculateMACDAtIndex(closes.slice(0, i + 1));
                    const macdPrev = calculateMACDAtIndex(closes.slice(0, i));
                    if (macdPrev < 0 && macdNow > 0) {
                        buySignals += 2;
                        reasons.push('MACDé‡‘å‰');
                    } else if (macdPrev > 0 && macdNow < 0) {
                        sellSignals += 2;
                        reasons.push('MACDæ­»å‰');
                    }
                }
                
                // æ£€æŸ¥æˆäº¤é‡
                if (i >= 5) {
                    const avgVolume = volumes.slice(i - 5, i).reduce((a, b) => a + b, 0) / 5;
                    if (volumes[i] > avgVolume * 1.5) {
                        if (closes[i] > closes[i - 1]) {
                            buySignals++;
                            reasons.push('æ”¾é‡ä¸Šæ¶¨');
                        } else {
                            sellSignals++;
                            reasons.push('æ”¾é‡ä¸‹è·Œ');
                        }
                    }
                }
                
                // æ£€æŸ¥æ–æ³¢é‚£å¥‘æ”¯æ’‘é˜»åŠ›
                if (fibonacci) {
                    const price = closes[i];
                    const nearSupport = fibonacci.support.some(s => Math.abs(price - s.price) / price < 0.01);
                    const nearResistance = fibonacci.resistance.some(r => Math.abs(price - r.price) / price < 0.01);
                    
                    if (nearSupport) {
                        buySignals++;
                        reasons.push('è§¦åŠæ–æ³¢é‚£å¥‘æ”¯æ’‘ä½');
                    }
                    if (nearResistance) {
                        sellSignals++;
                        reasons.push('è§¦åŠæ–æ³¢é‚£å¥‘é˜»åŠ›ä½');
                    }
                }
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºé»„é‡‘ç‚¹
                if (buySignals >= 3) {
                    points.push({
                        index: i,
                        type: 'buy',
                        price: closes[i],
                        confidence: Math.min(buySignals * 20, 100),
                        reasons: reasons.join(', ')
                    });
                } else if (sellSignals >= 3) {
                    points.push({
                        index: i,
                        type: 'sell',
                        price: closes[i],
                        confidence: Math.min(sellSignals * 20, 100),
                        reasons: reasons.join(', ')
                    });
                }
            }
            
            return points;
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŒ‡å®šä½ç½®çš„RSI
        function calculateRSIAtIndex(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŒ‡å®šä½ç½®çš„MACD
        function calculateMACDAtIndex(prices) {
            if (prices.length < 26) return 0;
            
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            return ema12 - ema26;
        }
        
        // ==================== é£é™©æ”¶ç›Šæ¯”åˆ†æ ====================
        function calculateRiskReward(currentPrice, recommendation) {
            const stopLoss = recommendation.stopLoss;
            const takeProfit = recommendation.takeProfit;
            
            // è®¡ç®—é£é™©å’Œæ”¶ç›Š
            const risk = Math.abs(currentPrice - stopLoss);
            const reward = Math.abs(takeProfit - currentPrice);
            
            // è®¡ç®—é£é™©æ”¶ç›Šæ¯”
            const ratio = reward / risk;
            
            // è®¡ç®—é£é™©å’Œæ”¶ç›Šçš„ç™¾åˆ†æ¯”
            const riskPercent = (risk / currentPrice) * 100;
            const rewardPercent = (reward / currentPrice) * 100;
            
            // æ ¹æ®é£é™©æ”¶ç›Šæ¯”ç»™å‡ºä»“ä½å»ºè®®
            let positionAdvice = '';
            let positionSize = 0;
            
            if (ratio >= 3) {
                positionAdvice = 'é£é™©æ”¶ç›Šæ¯”ä¼˜ç§€ï¼Œå¯ä»¥è€ƒè™‘æ ‡å‡†ä»“ä½ï¼ˆ20-30%ï¼‰';
                positionSize = 25;
            } else if (ratio >= 2) {
                positionAdvice = 'é£é™©æ”¶ç›Šæ¯”è‰¯å¥½ï¼Œå»ºè®®è½»ä»“æ“ä½œï¼ˆ10-20%ï¼‰';
                positionSize = 15;
            } else if (ratio >= 1.5) {
                positionAdvice = 'é£é™©æ”¶ç›Šæ¯”ä¸€èˆ¬ï¼Œå»ºè®®å°ä»“ä½è¯•æ¢ï¼ˆ5-10%ï¼‰';
                positionSize = 7;
            } else {
                positionAdvice = 'é£é™©æ”¶ç›Šæ¯”è¾ƒä½ï¼Œå»ºè®®è§‚æœ›æˆ–æå°ä»“ä½ï¼ˆ<5%ï¼‰';
                positionSize = 3;
            }
            
            // è®¡ç®—æœŸæœ›æ”¶ç›Šï¼ˆå‡è®¾èƒœç‡50%ï¼‰
            const expectedReturn = (reward * 0.5 - risk * 0.5) / currentPrice * 100;
            
            return {
                ratio: ratio.toFixed(2),
                risk: formatPrice(risk),
                reward: formatPrice(reward),
                riskPercent: riskPercent.toFixed(2),
                rewardPercent: rewardPercent.toFixed(2),
                positionAdvice,
                positionSize,
                expectedReturn: expectedReturn.toFixed(2)
            };
        }

        // ==================== åˆ†æ­§æ£€æµ‹å’Œä¿¡å·å¼ºåº¦ ====================
        function detectDivergence(recommendation) {
            // å¦‚æœæ²¡æœ‰å…±æŒ¯ç»“æœï¼Œè¿”å›é»˜è®¤å€¼
            if (!resonanceResult) {
                return {
                    hasDivergence: false,
                    signalStrength: 50,
                    consistency: 'æœªçŸ¥',
                    marketState: 'ç­‰å¾…å¤šå‘¨æœŸåˆ†æ',
                    actionAdvice: 'è¯·å…ˆå®Œæˆå¤šå‘¨æœŸå…±æŒ¯åˆ†æ'
                };
            }
            
            const { resonanceType } = resonanceResult;
            
            // æŠ€æœ¯åˆ†ææ–¹å‘
            let techDirection = 'neutral';
            if (recommendation.direction.includes('å¤šå¤´') || recommendation.direction.includes('ä¹°å…¥')) {
                techDirection = 'bullish';
            } else if (recommendation.direction.includes('ç©ºå¤´') || recommendation.direction.includes('å–å‡º')) {
                techDirection = 'bearish';
            }
            
            // æ£€æµ‹æ˜¯å¦æœ‰åˆ†æ­§
            const hasDivergence = (resonanceType !== techDirection && resonanceType !== 'neutral' && techDirection !== 'neutral');
            
            // è®¡ç®—ä¿¡å·å¼ºåº¦ï¼ˆ0-100ï¼‰
            let signalStrength = 50;
            let consistency = '';
            let marketState = '';
            let actionAdvice = '';
            
            if (!hasDivergence) {
                // æ— åˆ†æ­§ï¼Œä¿¡å·ä¸€è‡´
                if (resonanceType === 'bullish' && techDirection === 'bullish') {
                    signalStrength = Math.min(recommendation.score + 20, 100);
                    consistency = 'ğŸŸ¢ å¼ºçƒˆä¸€è‡´';
                    marketState = 'å¤šå‘¨æœŸå’ŒæŠ€æœ¯æŒ‡æ ‡å‡çœ‹æ¶¨ï¼Œè¶‹åŠ¿å‘ä¸Šç¡®è®¤';
                    actionAdvice = recommendation.score >= 70 ? 
                        'âœ… å¼ºçƒˆå»ºè®®ï¼šç§¯æä¹°å…¥ï¼Œè¿™æ˜¯é«˜æ¦‚ç‡çš„ä¸Šæ¶¨æœºä¼š' :
                        'âœ… å»ºè®®ï¼šå¯ä»¥é€æ­¥å»ºä»“ï¼Œè®¾ç½®å¥½æ­¢æŸ';
                } else if (resonanceType === 'bearish' && techDirection === 'bearish') {
                    signalStrength = Math.min(recommendation.score + 20, 100);
                    consistency = 'ğŸ”´ å¼ºçƒˆä¸€è‡´';
                    marketState = 'å¤šå‘¨æœŸå’ŒæŠ€æœ¯æŒ‡æ ‡å‡çœ‹è·Œï¼Œä¸‹è·Œé£é™©è¾ƒé«˜';
                    actionAdvice = recommendation.score >= 70 ?
                        'â›” å¼ºçƒˆå»ºè®®ï¼šç©ºä»“è§‚æœ›æˆ–åšç©ºï¼Œé¿å…æŠ„åº•' :
                        'âš ï¸ å»ºè®®ï¼šå‡ä»“æˆ–æ­¢æŸï¼Œç­‰å¾…ä¼ç¨³ä¿¡å·';
                } else {
                    // éƒ½æ˜¯neutral
                    signalStrength = 50;
                    consistency = 'âšª ä¿¡å·ä¸æ˜';
                    marketState = 'å¸‚åœºè¶‹åŠ¿ä¸æ˜ç¡®ï¼Œå¤„äºéœ‡è¡æˆ–è°ƒæ•´é˜¶æ®µ';
                    actionAdvice = 'ğŸ’¡ å»ºè®®ï¼šè§‚æœ›ä¸ºä¸»ï¼Œç­‰å¾…æ˜ç¡®ä¿¡å·åå†æ“ä½œ';
                }
            } else {
                // æœ‰åˆ†æ­§
                signalStrength = Math.abs(recommendation.score - 50);
                
                if (resonanceType === 'bullish' && techDirection === 'bearish') {
                    consistency = 'ğŸ”¶ åˆ†æ­§ï¼šé•¿æ¶¨çŸ­è·Œ';
                    marketState = 'é•¿æœŸè¶‹åŠ¿å‘ä¸Šï¼Œä½†çŸ­æœŸæŠ€æœ¯æŒ‡æ ‡æ˜¾ç¤ºå›è°ƒä¿¡å·';
                    actionAdvice = recommendation.score >= 70 ?
                        'âš ï¸ å»ºè®®ï¼šæš‚ç¼“ä¹°å…¥ï¼Œç­‰å¾…å›è°ƒåˆ°æ”¯æ’‘ä½ï¼›æŒä»“è€…å¯ä»¥éƒ¨åˆ†æ­¢ç›ˆ' :
                        'ğŸ’¡ å»ºè®®ï¼šè½»ä»“æˆ–è§‚æœ›ï¼Œå›è°ƒç»“æŸåæ˜¯æ›´å¥½çš„ä¹°å…¥æ—¶æœº';
                } else if (resonanceType === 'bearish' && techDirection === 'bullish') {
                    consistency = 'ğŸ”· åˆ†æ­§ï¼šé•¿è·ŒçŸ­æ¶¨';
                    marketState = 'é•¿æœŸè¶‹åŠ¿å‘ä¸‹ï¼ŒçŸ­æœŸæŠ€æœ¯æŒ‡æ ‡æ˜¾ç¤ºåå¼¹ä¿¡å·';
                    actionAdvice = recommendation.score >= 70 ?
                        'âš ï¸ å»ºè®®ï¼šåå¼¹ä¸æ˜¯åè½¬ï¼Œè°¨æ…è¿½é«˜ï¼Œæ³¨æ„æ­¢ç›ˆ' :
                        'ğŸ’¡ å»ºè®®ï¼šå°ä»“ä½å‚ä¸åå¼¹ï¼Œä¸¥æ ¼è®¾ç½®æ­¢æŸï¼Œä¸è¦æ‹æˆ˜';
                } else {
                    consistency = 'âšª ä¿¡å·æ··ä¹±';
                    marketState = 'å¤šå‘¨æœŸå’ŒæŠ€æœ¯åˆ†æä¿¡å·ä¸ä¸€è‡´ï¼Œå¸‚åœºæ–¹å‘ä¸æ˜';
                    actionAdvice = 'ğŸ›‘ å»ºè®®ï¼šç©ºä»“è§‚æœ›ï¼Œç­‰å¾…ä¿¡å·æ˜ç¡®åå†æ“ä½œ';
                }
            }
            
            return {
                hasDivergence,
                signalStrength: signalStrength.toFixed(0),
                consistency,
                marketState,
                actionAdvice,
                resonanceType,
                techDirection
            };
        }

        // ==================== æŠ€æœ¯æŒ‡æ ‡è®¡ç®— ====================
        function calculateMA(prices) {
            const periods = [7, 30, 60, 120, 240];
            const result = {};
            
            periods.forEach(period => {
                if (prices.length >= period) {
                    const ma = prices.slice(-period).reduce((a, b) => a + b, 0) / period;
                    result[`MA${period}`] = ma;
                }
            });
            
            return result;
        }

        function calculateMACD(prices) {
            if (prices.length < 34) return null; // éœ€è¦è‡³å°‘34ä¸ªæ•°æ®ç‚¹
            
            // è®¡ç®—EMA12å’ŒEMA26
            const ema12Array = [];
            const ema26Array = [];
            
            let ema12 = prices[0];
            let ema26 = prices[0];
            const k12 = 2 / (12 + 1);
            const k26 = 2 / (26 + 1);
            
            for (let i = 0; i < prices.length; i++) {
                ema12 = prices[i] * k12 + ema12 * (1 - k12);
                ema26 = prices[i] * k26 + ema26 * (1 - k26);
                ema12Array.push(ema12);
                ema26Array.push(ema26);
            }
            
            // è®¡ç®—DIF (MACDçº¿)
            const difArray = [];
            for (let i = 0; i < prices.length; i++) {
                difArray.push(ema12Array[i] - ema26Array[i]);
            }
            
            // è®¡ç®—DEA (ä¿¡å·çº¿) - DIFçš„9æ—¥EMA
            let dea = difArray[0];
            const deaArray = [];
            const k9 = 2 / (9 + 1);
            
            for (let i = 0; i < difArray.length; i++) {
                dea = difArray[i] * k9 + dea * (1 - k9);
                deaArray.push(dea);
            }
            
            // è®¡ç®—MACDæŸ± (Histogram)
            const histogram = [];
            for (let i = 0; i < difArray.length; i++) {
                histogram.push((difArray[i] - deaArray[i]) * 2);
            }
            
            const currentDIF = difArray[difArray.length - 1];
            const currentDEA = deaArray[deaArray.length - 1];
            const currentHistogram = histogram[histogram.length - 1];
            
            return {
                DIF: currentDIF,
                DEA: currentDEA,
                MACD: currentHistogram,
                histogram: histogram, // å®Œæ•´çš„æŸ±çŠ¶å›¾æ•°ç»„
                signal: currentHistogram > 0 ? 'ä¹°å…¥' : 'å–å‡º'
            };
        }

        function calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            
            return ema;
        }

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return null;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            return rsi;
        }

        function calculateBOLL(prices, period = 20) {
            if (prices.length < period) return null;
            
            const recentPrices = prices.slice(-period);
            const middle = recentPrices.reduce((a, b) => a + b, 0) / period;
            
            const variance = recentPrices.reduce((sum, price) => {
                return sum + Math.pow(price - middle, 2);
            }, 0) / period;
            
            const std = Math.sqrt(variance);
            
            return {
                upper: middle + 2 * std,
                middle: middle,
                lower: middle - 2 * std
            };
        }

        function calculateKDJ(highs, lows, closes, period = 9, smoothK = 3, smoothD = 3) {
            if (closes.length < period) return null;
            
            // è®¡ç®—æ‰€æœ‰RSVå€¼
            const rsvArray = [];
            for (let i = period - 1; i < closes.length; i++) {
                const recentHighs = highs.slice(i - period + 1, i + 1);
                const recentLows = lows.slice(i - period + 1, i + 1);
                const currentClose = closes[i];
                
                const highest = Math.max(...recentHighs);
                const lowest = Math.min(...recentLows);
                
                let rsv = 50;
                if (highest !== lowest) {
                    rsv = ((currentClose - lowest) / (highest - lowest)) * 100;
                }
                rsvArray.push(rsv);
            }
            
            // è®¡ç®—Kå€¼ (RSVçš„smoothKæ—¥ç§»åŠ¨å¹³å‡)
            const kArray = [];
            let k = 50; // åˆå§‹Kå€¼ä¸º50
            
            for (let i = 0; i < rsvArray.length; i++) {
                k = (rsvArray[i] + (smoothK - 1) * k) / smoothK;
                kArray.push(k);
            }
            
            // è®¡ç®—Då€¼ (Kå€¼çš„smoothDæ—¥ç§»åŠ¨å¹³å‡)
            const dArray = [];
            let d = 50; // åˆå§‹Då€¼ä¸º50
            
            for (let i = 0; i < kArray.length; i++) {
                d = (kArray[i] + (smoothD - 1) * d) / smoothD;
                dArray.push(d);
            }
            
            // è®¡ç®—Jå€¼ (J = 3K - 2D)
            const jArray = [];
            for (let i = 0; i < kArray.length; i++) {
                const j = 3 * kArray[i] - 2 * dArray[i];
                jArray.push(j);
            }
            
            // è¿”å›æœ€æ–°çš„KDJå€¼
            const currentK = kArray[kArray.length - 1];
            const currentD = dArray[dArray.length - 1];
            const currentJ = jArray[jArray.length - 1];
            
            return { 
                K: currentK, 
                D: currentD, 
                J: currentJ 
            };
        }

        function calculateVOL(volumes, period = 5) {
            if (volumes.length < period) return null;
            
            const recentVolumes = volumes.slice(-period);
            const currentVolume = volumes[volumes.length - 1];
            const avgVolume = recentVolumes.reduce((a, b) => a + b, 0) / period;
            
            // è®¡ç®—æˆäº¤é‡æ¯”ç‡
            const volumeRatio = currentVolume / avgVolume;
            
            // åˆ¤æ–­æˆäº¤é‡çŠ¶æ€
            let signal = 'neutral';
            let status = '';
            
            if (volumeRatio > 2) {
                signal = 'buy';
                status = 'æ”¾é‡çªç ´';
            } else if (volumeRatio > 1.5) {
                signal = 'buy';
                status = 'æ¸©å’Œæ”¾é‡';
            } else if (volumeRatio < 0.5) {
                signal = 'sell';
                status = 'ç¼©é‡æ˜æ˜¾';
            } else if (volumeRatio < 0.7) {
                signal = 'neutral';
                status = 'é‡èƒ½èç¼©';
            } else {
                signal = 'neutral';
                status = 'é‡èƒ½å¹³ç¨³';
            }
            
            return {
                currentVolume,
                avgVolume,
                volumeRatio,
                signal,
                status
            };
        }

        // ==================== äº¤æ˜“ç†è®ºåˆ†æ ====================
        
        // æ–æ³¢é‚£å¥‘åˆ†æ
        // ==================== æ–æ³¢é‚£å¥‘åˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰====================
        function calculateFibonacci(highs, lows, currentPrice) {
            // 1. è‡ªåŠ¨è¯†åˆ«æ³¢æ®µé«˜ä½ç‚¹ï¼ˆlookback=10æ ¹Kçº¿ï¼‰
            const swingPoints = findSwingPoints(highs, lows, 10);
            
            if (swingPoints.swingHighs.length === 0 || swingPoints.swingLows.length === 0) {
                return {
                    high: Math.max(...highs.slice(-20)),
                    low: Math.min(...lows.slice(-20)),
                    levels: {},
                    support: [],
                    resistance: [],
                    position: 'æ•°æ®ä¸è¶³',
                    signal: 'neutral',
                    confidence: 0,
                    analysis: 'æ³¢æ®µæ•°æ®ä¸è¶³ï¼Œæ— æ³•è¿›è¡Œæ–æ³¢é‚£å¥‘åˆ†æ'
                };
            }
            
            // 2. è·å–æœ€è¿‘çš„ä¸»è¦æ³¢æ®µï¼ˆæœ€åä¸€ä¸ªé«˜ç‚¹å’Œä½ç‚¹ï¼‰
            const lastHigh = swingPoints.swingHighs[swingPoints.swingHighs.length - 1];
            const lastLow = swingPoints.swingLows[swingPoints.swingLows.length - 1];
            
            // 3. ç¡®å®šè¶‹åŠ¿æ–¹å‘
            const isUptrend = lastHigh.index > lastLow.index;
            const high = isUptrend ? lastHigh.price : (swingPoints.swingHighs[swingPoints.swingHighs.length - 2]?.price || lastHigh.price);
            const low = isUptrend ? (swingPoints.swingLows[swingPoints.swingLows.length - 2]?.price || lastLow.price) : lastLow.price;
            
            // 4. è®¡ç®—æ–æ³¢é‚£å¥‘å›æ’¤ä½ï¼ˆå¸åœˆæ ‡å‡†ï¼‰
            const range = high - low;
            const fibLevels = {
                '0%': high,
                '23.6%': high - range * 0.236,
                '38.2%': high - range * 0.382,
                '50%': high - range * 0.5,
                '61.8%': high - range * 0.618,
                '78.6%': high - range * 0.786,
                '88.6%': high - range * 0.886,
                '100%': low
            };
            
            // 5. è®¡ç®—æ‰©å±•ä½ï¼ˆç”¨äºæ­¢ç›ˆç›®æ ‡ï¼‰
            const extensions = {
                '127.2%': low + range * 1.272,
                '141.4%': low + range * 1.414,
                '161.8%': low + range * 1.618,
                '200%': low + range * 2.0,
                '261.8%': low + range * 2.618
            };
            
            // 6. å¯»æ‰¾æœ€è¿‘çš„æ–æ³¢é‚£å¥‘æ°´å¹³
            const nearestLevels = findNearestFibLevels(currentPrice, fibLevels);
            
            // 7. å¤šé‡å…±æŒ¯åˆ†æï¼ˆæ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªæ³¢æ®µçš„æ–æ³¢é‚£å¥‘æ°´å¹³é‡åˆï¼‰
            const resonance = checkFibonacciResonance(swingPoints, currentPrice);
            
            // 8. åˆ¤æ–­å½“å‰ä½ç½®å’Œä¿¡å·å¼ºåº¦
            let position = '';
            let signal = 'neutral';
            let confidence = 0;
            let tradingZone = '';
            
            const nearest = nearestLevels[0];
            const secondNearest = nearestLevels[1];
            
            // é»„é‡‘å†³ç­–åŒºï¼ˆ38.2% - 61.8%ï¼‰
            if (currentPrice >= fibLevels['61.8%'] && currentPrice <= fibLevels['38.2%']) {
                tradingZone = 'é»„é‡‘å†³ç­–åŒº';
                if (isUptrend && currentPrice <= fibLevels['61.8%'] * 1.02) {
                    position = 'æ¥è¿‘é»„é‡‘åˆ†å‰²ä½ï¼ˆ61.8%ï¼‰ï¼Œå¼ºæ”¯æ’‘åŒºåŸŸ';
                    signal = 'buy';
                    confidence = 0.75 + (resonance.count * 0.05); // å…±æŒ¯å¢åŠ ç½®ä¿¡åº¦
                } else if (isUptrend && currentPrice >= fibLevels['38.2%'] * 0.98) {
                    position = 'æ¥è¿‘38.2%å›æ’¤ä½ï¼Œè½»åº¦æ”¯æ’‘';
                    signal = 'buy';
                    confidence = 0.65 + (resonance.count * 0.05);
                } else {
                    position = 'å¤„äºå†³ç­–åŒºå†…ï¼Œç­‰å¾…æ˜ç¡®ä¿¡å·';
                    signal = 'neutral';
                    confidence = 0.5;
                }
            }
            // æ·±åº¦å›æ’¤åŒºï¼ˆ78.6% - 88.6%ï¼‰
            else if (currentPrice >= fibLevels['88.6%'] && currentPrice <= fibLevels['78.6%']) {
                tradingZone = 'æ·±åº¦å›æ’¤åŒº';
                position = 'æ·±åº¦å›æ’¤ï¼Œè¶‹åŠ¿å¯èƒ½åè½¬';
                signal = isUptrend ? 'buy' : 'sell';
                confidence = 0.6 + (resonance.count * 0.05);
            }
            // çªç ´åŒºï¼ˆè¶…è¿‡0%æˆ–ä½äº100%ï¼‰
            else if (currentPrice > high) {
                tradingZone = 'çªç ´å»¶ä¼¸åŒº';
                position = 'å·²çªç ´é«˜ç‚¹ï¼Œçœ‹å‘æ‰©å±•ä½';
                signal = 'hold';
                confidence = 0.7;
            }
            else if (currentPrice < low) {
                tradingZone = 'è·Œç ´æ”¯æ’‘åŒº';
                position = 'è·Œç ´ä½ç‚¹ï¼Œè¶‹åŠ¿å¯èƒ½å·²åè½¬';
                signal = 'sell';
                confidence = 0.75;
            }
            else {
                tradingZone = 'å¸¸è§„åŒºåŸŸ';
                position = `æ¥è¿‘${nearest.level}æ°´å¹³`;
                signal = 'neutral';
                confidence = 0.5;
            }
            
            // 9. æ‰¾å‡ºæ”¯æ’‘ä½å’Œé˜»åŠ›ä½
            const support = [];
            const resistance = [];
            
            Object.entries(fibLevels).forEach(([level, price]) => {
                const distance = Math.abs(currentPrice - price);
                const distancePercent = (distance / currentPrice) * 100;
                
                if (price < currentPrice) {
                    support.push({ 
                        level, 
                        price,
                        distance: distancePercent.toFixed(2) + '%',
                        importance: getFibLevelImportance(level)
                    });
                } else if (price > currentPrice) {
                    resistance.push({ 
                        level, 
                        price,
                        distance: distancePercent.toFixed(2) + '%',
                        importance: getFibLevelImportance(level)
                    });
                }
            });
            
            // æŒ‰é‡è¦æ€§å’Œè·ç¦»æ’åº
            support.sort((a, b) => b.importance - a.importance);
            resistance.sort((a, b) => b.importance - a.importance);
            
            return {
                high,
                low,
                range,
                levels: fibLevels,
                extensions,
                support: support.slice(0, 3),
                resistance: resistance.slice(0, 3),
                position,
                signal,
                confidence: Math.min(confidence, 0.95),
                tradingZone,
                resonance,
                nearestLevel: nearest,
                isUptrend,
                analysis: `${tradingZone}ï¼š${position}${resonance.count > 0 ? `ï¼ˆ${resonance.count}é‡å…±æŒ¯ï¼‰` : ''}`
            };
        }
        
        // è¯†åˆ«æ³¢æ®µé«˜ä½ç‚¹
        function findSwingPoints(highs, lows, lookback = 5) {
            const swingHighs = [];
            const swingLows = [];
            
            for (let i = lookback; i < highs.length - lookback; i++) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ³¢æ®µé«˜ç‚¹
                let isSwingHigh = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j !== i && highs[j] >= highs[i]) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ³¢æ®µä½ç‚¹
                let isSwingLow = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j !== i && lows[j] <= lows[i]) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingHigh) swingHighs.push({ index: i, price: highs[i] });
                if (isSwingLow) swingLows.push({ index: i, price: lows[i] });
            }
            
            return { swingHighs, swingLows };
        }
        
        // å¯»æ‰¾æœ€è¿‘çš„æ–æ³¢é‚£å¥‘æ°´å¹³
        function findNearestFibLevels(currentPrice, fibLevels) {
            const distances = [];
            
            Object.entries(fibLevels).forEach(([level, price]) => {
                const distance = Math.abs(currentPrice - price);
                const distancePercent = (distance / currentPrice) * 100;
                const type = currentPrice > price ? 'support' : 'resistance';
                
                distances.push({
                    level,
                    price,
                    distance,
                    distancePercent,
                    type,
                    importance: getFibLevelImportance(level)
                });
            });
            
            return distances.sort((a, b) => a.distance - b.distance);
        }
        
        // è·å–æ–æ³¢é‚£å¥‘æ°´å¹³çš„é‡è¦æ€§
        function getFibLevelImportance(level) {
            const importanceMap = {
                '61.8%': 10,  // é»„é‡‘åˆ†å‰²ä½ï¼Œæœ€é‡è¦
                '38.2%': 8,
                '78.6%': 7,
                '50%': 6,
                '23.6%': 5,
                '88.6%': 5,
                '0%': 4,
                '100%': 4
            };
            return importanceMap[level] || 1;
        }
        
        // å¤šé‡å…±æŒ¯åˆ†æ
        function checkFibonacciResonance(swingPoints, currentPrice) {
            let resonanceCount = 0;
            const resonanceLevels = [];
            
            // æ£€æŸ¥æœ€è¿‘3ä¸ªæ³¢æ®µçš„æ–æ³¢é‚£å¥‘æ°´å¹³
            const recentHighs = swingPoints.swingHighs.slice(-3);
            const recentLows = swingPoints.swingLows.slice(-3);
            
            for (let i = 0; i < Math.min(recentHighs.length, recentLows.length); i++) {
                const high = recentHighs[i]?.price;
                const low = recentLows[i]?.price;
                
                if (!high || !low) continue;
                
                const range = high - low;
                const fib618 = high - range * 0.618;
                const fib382 = high - range * 0.382;
                const fib50 = high - range * 0.5;
                
                // æ£€æŸ¥å½“å‰ä»·æ ¼æ˜¯å¦åœ¨è¿™äº›æ°´å¹³é™„è¿‘ï¼ˆ1%èŒƒå›´å†…ï¼‰
                const threshold = currentPrice * 0.01;
                
                if (Math.abs(currentPrice - fib618) < threshold) {
                    resonanceCount++;
                    resonanceLevels.push('61.8%');
                } else if (Math.abs(currentPrice - fib382) < threshold) {
                    resonanceCount++;
                    resonanceLevels.push('38.2%');
                } else if (Math.abs(currentPrice - fib50) < threshold) {
                    resonanceCount++;
                    resonanceLevels.push('50%');
                }
            }
            
            return {
                count: resonanceCount,
                levels: [...new Set(resonanceLevels)],
                description: resonanceCount > 0 ? `${resonanceCount}ä¸ªå‘¨æœŸçš„æ–æ³¢é‚£å¥‘æ°´å¹³åœ¨æ­¤é‡åˆï¼Œæ”¯æ’‘/é˜»åŠ›å¼ºåº¦å¤§å¢` : 'æ— æ˜æ˜¾å…±æŒ¯'
            };
        }
        
        // æ³¢æµªç†è®ºåˆ†æ
        // ==================== æ³¢æµªç†è®ºåˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰====================
        function analyzeElliottWave(closes, highs, lows, volumes, macdData, rsiData) {
            if (closes.length < 30) {
                return {
                    pattern: 'æ•°æ®ä¸è¶³',
                    prediction: 'æ— æ³•åˆ†æ',
                    confidence: 0,
                    signal: 'neutral',
                    waveCount: 0,
                    waves: [],
                    currentWave: null,
                    fibonacciTargets: [],
                    analysis: 'æ•°æ®ä¸è¶³ï¼Œéœ€è¦è‡³å°‘30æ ¹Kçº¿'
                };
            }
            
            // 1. æ£€æµ‹æå€¼ç‚¹ï¼ˆå³°å€¼å’Œè°·å€¼ï¼‰
            const extremes = detectWaveExtremes(highs, lows, closes);
            
            // 2. è¯†åˆ«5æµªé©±åŠ¨ç»“æ„
            const impulseWaves = identifyImpulseWaves(extremes, closes);
            
            // 3. è¯†åˆ«è°ƒæ•´æµªï¼ˆABCï¼‰
            const correctiveWaves = identifyCorrectiveWaves(extremes, impulseWaves);
            
            // 4. éªŒè¯æ³¢æµªè§„åˆ™
            const validWaves = validateElliottRules(impulseWaves, closes);
            
            // 5. åˆ†ææ–æ³¢é‚£å¥‘æ¯”ç‡å…³ç³»
            const fibonacciAnalysis = analyzeWaveFibonacci(validWaves, closes);
            
            // 6. ç¡®è®¤æˆäº¤é‡ç‰¹å¾
            const volumeConfirmation = confirmWaveVolume(validWaves, volumes);
            
            // 7. æ£€æµ‹èƒŒç¦»
            const divergence = detectWaveDivergence(validWaves, macdData, rsiData);
            
            // 8. ç¡®å®šå½“å‰æ‰€å¤„æ³¢æµª
            const currentWaveAnalysis = identifyCurrentWave(validWaves, extremes, closes);
            
            // 9. ç”Ÿæˆäº¤æ˜“ä¿¡å·
            const tradingSignal = generateWaveSignal(currentWaveAnalysis, fibonacciAnalysis, volumeConfirmation, divergence);
            
            return {
                pattern: currentWaveAnalysis.pattern,
                prediction: tradingSignal.prediction,
                signal: tradingSignal.signal,
                confidence: tradingSignal.confidence,
                waveCount: extremes.peaks.length + extremes.troughs.length,
                waves: validWaves,
                currentWave: currentWaveAnalysis.currentWave,
                extremes: extremes,
                fibonacciTargets: fibonacciAnalysis.targets,
                fibonacciRelations: fibonacciAnalysis.relations,
                volumeProfile: volumeConfirmation,
                divergence: divergence,
                action: tradingSignal.action,
                targets: tradingSignal.targets,
                stopLoss: tradingSignal.stopLoss,
                analysis: tradingSignal.analysis,
                wavePersonality: currentWaveAnalysis.personality
            };
        }
        
        // 1. æ£€æµ‹æå€¼ç‚¹
        function detectWaveExtremes(highs, lows, closes) {
            const peaks = [];
            const troughs = [];
            const lookback = 5; // æ›´ä¸¥æ ¼çš„æå€¼ç‚¹æ£€æµ‹
            
            for (let i = lookback; i < closes.length - lookback; i++) {
                // æ£€æµ‹å³°å€¼
                let isPeak = true;
                for (let j = 1; j <= lookback; j++) {
                    if (highs[i] <= highs[i - j] || highs[i] <= highs[i + j]) {
                        isPeak = false;
                        break;
                    }
                }
                if (isPeak) {
                    peaks.push({
                        index: i,
                        price: highs[i],
                        type: 'peak'
                    });
                }
                
                // æ£€æµ‹è°·å€¼
                let isTrough = true;
                for (let j = 1; j <= lookback; j++) {
                    if (lows[i] >= lows[i - j] || lows[i] >= lows[i + j]) {
                        isTrough = false;
                        break;
                    }
                }
                if (isTrough) {
                    troughs.push({
                        index: i,
                        price: lows[i],
                        type: 'trough'
                    });
                }
            }
            
            return { peaks, troughs };
        }
        
        // 2. è¯†åˆ«5æµªé©±åŠ¨ç»“æ„
        function identifyImpulseWaves(extremes, closes) {
            const allExtremes = [...extremes.peaks, ...extremes.troughs]
                .sort((a, b) => a.index - b.index);
            
            const impulseWaves = [];
            
            // å¯»æ‰¾5æµªç»“æ„
            for (let i = 0; i < allExtremes.length - 4; i++) {
                const potential5Waves = allExtremes.slice(i, i + 6); // éœ€è¦6ä¸ªæå€¼ç‚¹å½¢æˆ5æµª
                
                if (potential5Waves.length < 6) continue;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸Šå‡5æµª (è°·-å³°-è°·-å³°-è°·-å³°)
                if (potential5Waves[0].type === 'trough' && 
                    potential5Waves[1].type === 'peak' &&
                    potential5Waves[2].type === 'trough' &&
                    potential5Waves[3].type === 'peak' &&
                    potential5Waves[4].type === 'trough' &&
                    potential5Waves[5].type === 'peak') {
                    
                    impulseWaves.push({
                        direction: 'up',
                        start: potential5Waves[0],
                        wave1End: potential5Waves[1],
                        wave2End: potential5Waves[2],
                        wave3End: potential5Waves[3],
                        wave4End: potential5Waves[4],
                        wave5End: potential5Waves[5],
                        waves: potential5Waves
                    });
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‹è·Œ5æµª (å³°-è°·-å³°-è°·-å³°-è°·)
                if (potential5Waves[0].type === 'peak' && 
                    potential5Waves[1].type === 'trough' &&
                    potential5Waves[2].type === 'peak' &&
                    potential5Waves[3].type === 'trough' &&
                    potential5Waves[4].type === 'peak' &&
                    potential5Waves[5].type === 'trough') {
                    
                    impulseWaves.push({
                        direction: 'down',
                        start: potential5Waves[0],
                        wave1End: potential5Waves[1],
                        wave2End: potential5Waves[2],
                        wave3End: potential5Waves[3],
                        wave4End: potential5Waves[4],
                        wave5End: potential5Waves[5],
                        waves: potential5Waves
                    });
                }
            }
            
            return impulseWaves;
        }
        
        // 3. è¯†åˆ«è°ƒæ•´æµª
        function identifyCorrectiveWaves(extremes, impulseWaves) {
            // ç®€åŒ–å®ç°ï¼šåœ¨é©±åŠ¨æµªä¹‹åå¯»æ‰¾ABCè°ƒæ•´
            const correctiveWaves = [];
            
            impulseWaves.forEach(impulse => {
                const endIndex = impulse.wave5End.index;
                const allExtremes = [...extremes.peaks, ...extremes.troughs]
                    .sort((a, b) => a.index - b.index);
                
                // å¯»æ‰¾é©±åŠ¨æµªåçš„3ä¸ªæå€¼ç‚¹ï¼ˆABCï¼‰
                const afterWave5 = allExtremes.filter(e => e.index > endIndex).slice(0, 3);
                if (afterWave5.length === 3) {
                    correctiveWaves.push({
                        afterImpulse: impulse,
                        waveA: afterWave5[0],
                        waveB: afterWave5[1],
                        waveC: afterWave5[2]
                    });
                }
            });
            
            return correctiveWaves;
        }
        
        // 4. éªŒè¯æ³¢æµªè§„åˆ™
        function validateElliottRules(impulseWaves, closes) {
            const validWaves = [];
            
            impulseWaves.forEach(wave => {
                let isValid = true;
                let violations = [];
                
                // è§„åˆ™1ï¼šæµª2ä¸å›æ’¤æµª1çš„100%
                const wave1Move = Math.abs(wave.wave1End.price - wave.start.price);
                const wave2Retracement = Math.abs(wave.wave2End.price - wave.wave1End.price);
                const retracement2 = wave2Retracement / wave1Move;
                
                if (retracement2 >= 1.0) {
                    violations.push('æµª2å›æ’¤è¶…è¿‡100%');
                    isValid = false;
                }
                
                // è§„åˆ™2ï¼šæµª3ä¸èƒ½æ˜¯æœ€çŸ­çš„é©±åŠ¨æµª
                const wave1Length = Math.abs(wave.wave1End.price - wave.start.price);
                const wave3Length = Math.abs(wave.wave3End.price - wave.wave2End.price);
                const wave5Length = Math.abs(wave.wave5End.price - wave.wave4End.price);
                
                if (wave3Length < wave1Length && wave3Length < wave5Length) {
                    violations.push('æµª3æ˜¯æœ€çŸ­çš„é©±åŠ¨æµª');
                    isValid = false;
                }
                
                // è§„åˆ™3ï¼šæµª4ä¸ä¸æµª1é‡å ï¼ˆå¸åœˆé€‚å½“æ”¾å®½ï¼‰
                if (wave.direction === 'up') {
                    if (wave.wave4End.price < wave.wave1End.price * 0.95) {
                        violations.push('æµª4ä¸æµª1ä¸¥é‡é‡å ');
                        // åœ¨å¸åœˆå¯ä»¥å®¹å¿è½»å¾®é‡å 
                    }
                } else {
                    if (wave.wave4End.price > wave.wave1End.price * 1.05) {
                        violations.push('æµª4ä¸æµª1ä¸¥é‡é‡å ');
                    }
                }
                
                // å³ä½¿æœ‰è½»å¾®è¿è§„ï¼Œä¹Ÿä¿ç•™ï¼ˆå¸åœˆç‰¹æ®Šæ€§ï¼‰
                validWaves.push({
                    ...wave,
                    isValid: violations.length === 0,
                    violations,
                    wave1Length,
                    wave3Length,
                    wave5Length,
                    retracement2
                });
            });
            
            return validWaves;
        }
        
        // 5. åˆ†ææ–æ³¢é‚£å¥‘æ¯”ç‡å…³ç³»
        function analyzeWaveFibonacci(validWaves, closes) {
            const fibonacciAnalysis = {
                relations: [],
                targets: []
            };
            
            validWaves.forEach(wave => {
                // æµª3ä¸æµª1çš„æ¯”ç‡ï¼ˆæœŸæœ›1.618ï¼‰
                const wave3to1Ratio = wave.wave3Length / wave.wave1Length;
                const is3Extended = wave3to1Ratio >= 1.5 && wave3to1Ratio <= 2.0;
                
                // æµª5ä¸æµª1çš„æ¯”ç‡ï¼ˆæœŸæœ›1.0æˆ–0.618ï¼‰
                const wave5to1Ratio = wave.wave5Length / wave.wave1Length;
                const is5Equal = Math.abs(wave5to1Ratio - 1.0) < 0.2;
                const is5Fibonacci = Math.abs(wave5to1Ratio - 0.618) < 0.1;
                
                fibonacciAnalysis.relations.push({
                    wave3to1: wave3to1Ratio.toFixed(2),
                    is3Extended,
                    wave5to1: wave5to1Ratio.toFixed(2),
                    is5Proportional: is5Equal || is5Fibonacci,
                    quality: (is3Extended && (is5Equal || is5Fibonacci)) ? 'excellent' : 'good'
                });
                
                // è®¡ç®—ç›®æ ‡ä½
                if (wave.direction === 'up') {
                    const wave1to3Distance = wave.wave3End.price - wave.start.price;
                    const target1618 = wave.wave4End.price + wave1to3Distance * 0.618;
                    const target100 = wave.wave4End.price + wave.wave1Length;
                    
                    fibonacciAnalysis.targets.push({
                        level: '0.618æ‰©å±•',
                        price: target1618,
                        probability: 'high'
                    });
                    fibonacciAnalysis.targets.push({
                        level: '1.0æ‰©å±•',
                        price: target100,
                        probability: 'medium'
                    });
                }
            });
            
            return fibonacciAnalysis;
        }
        
        // 6. ç¡®è®¤æˆäº¤é‡
        function confirmWaveVolume(validWaves, volumes) {
            if (!volumes || volumes.length === 0) {
                return { hasData: false };
            }
            
            const confirmation = {
                hasData: true,
                wave3VolumeExpansion: false,
                wave5VolumeDivergence: false
            };
            
            validWaves.forEach(wave => {
                // æµª3åº”è¯¥æ”¾é‡
                const wave3StartIdx = wave.wave2End.index;
                const wave3EndIdx = wave.wave3End.index;
                const wave3Volumes = volumes.slice(wave3StartIdx, wave3EndIdx + 1);
                const avgWave3Volume = wave3Volumes.reduce((a, b) => a + b, 0) / wave3Volumes.length;
                
                // æµª1æˆäº¤é‡
                const wave1StartIdx = wave.start.index;
                const wave1EndIdx = wave.wave1End.index;
                const wave1Volumes = volumes.slice(wave1StartIdx, wave1EndIdx + 1);
                const avgWave1Volume = wave1Volumes.reduce((a, b) => a + b, 0) / wave1Volumes.length;
                
                confirmation.wave3VolumeExpansion = avgWave3Volume > avgWave1Volume * 1.2;
                
                // æµª5å¯èƒ½ç¼©é‡
                if (wave.wave5End) {
                    const wave5StartIdx = wave.wave4End.index;
                    const wave5EndIdx = wave.wave5End.index;
                    const wave5Volumes = volumes.slice(wave5StartIdx, wave5EndIdx + 1);
                    const avgWave5Volume = wave5Volumes.reduce((a, b) => a + b, 0) / wave5Volumes.length;
                    
                    confirmation.wave5VolumeDivergence = avgWave5Volume < avgWave3Volume * 0.8;
                }
            });
            
            return confirmation;
        }
        
        // 7. æ£€æµ‹èƒŒç¦»
        function detectWaveDivergence(validWaves, macdData, rsiData) {
            const divergence = {
                hasMacdDivergence: false,
                hasRsiDivergence: false,
                type: null
            };
            
            if (!macdData || macdData.length === 0 || !rsiData || rsiData.length === 0) {
                return divergence;
            }
            
            validWaves.forEach(wave => {
                if (wave.wave5End && wave.wave3End) {
                    const wave3Idx = wave.wave3End.index;
                    const wave5Idx = wave.wave5End.index;
                    
                    if (wave5Idx < macdData.length && wave3Idx < macdData.length) {
                        // é¡¶èƒŒç¦»ï¼šä»·æ ¼æ–°é«˜ï¼ŒMACDä¸åˆ›æ–°é«˜
                        if (wave.direction === 'up') {
                            if (wave.wave5End.price > wave.wave3End.price) {
                                if (macdData[wave5Idx] < macdData[wave3Idx]) {
                                    divergence.hasMacdDivergence = true;
                                    divergence.type = 'bearish';
                                }
                                if (rsiData[wave5Idx] < rsiData[wave3Idx]) {
                                    divergence.hasRsiDivergence = true;
                                    divergence.type = 'bearish';
                                }
                            }
                        }
                        // åº•èƒŒç¦»ï¼šä»·æ ¼æ–°ä½ï¼ŒMACDä¸åˆ›æ–°ä½
                        else {
                            if (wave.wave5End.price < wave.wave3End.price) {
                                if (macdData[wave5Idx] > macdData[wave3Idx]) {
                                    divergence.hasMacdDivergence = true;
                                    divergence.type = 'bullish';
                                }
                                if (rsiData[wave5Idx] > rsiData[wave3Idx]) {
                                    divergence.hasRsiDivergence = true;
                                    divergence.type = 'bullish';
                                }
                            }
                        }
                    }
                }
            });
            
            return divergence;
        }
        
        // 8. ç¡®å®šå½“å‰æ³¢æµª
        function identifyCurrentWave(validWaves, extremes, closes) {
            const currentPrice = closes[closes.length - 1];
            let currentWave = null;
            let pattern = 'è¶‹åŠ¿ä¸æ˜';
            let personality = 'è§‚å¯ŸæœŸ';
            
            if (validWaves.length === 0) {
                return { currentWave: null, pattern, personality };
            }
            
            // æ‰¾åˆ°æœ€è¿‘çš„æ³¢æµª
            const latestWave = validWaves[validWaves.length - 1];
            const lastExtremeIndex = latestWave.wave5End.index;
            const currentIndex = closes.length - 1;
            
            // åˆ¤æ–­å½“å‰å¤„äºå“ªä¸€æµª
            if (currentIndex > lastExtremeIndex) {
                // 5æµªå·²å®Œæˆï¼Œå¯èƒ½åœ¨è°ƒæ•´æµª
                currentWave = 'Aæµªè°ƒæ•´';
                pattern = '5æµªé©±åŠ¨ç»“æŸï¼Œè¿›å…¥è°ƒæ•´';
                personality = 'å¤§å¤šæ•°äººè®¤ä¸ºæ˜¯æ­£å¸¸å›è°ƒï¼Œå®é™…å¯èƒ½æ˜¯è¶‹åŠ¿åè½¬';
            } else if (currentIndex >= latestWave.wave4End.index) {
                currentWave = 'æµª5';
                pattern = 'ç¬¬5æµªï¼ˆæœ€åæ¨åŠ¨ï¼‰';
                personality = 'å¸‚åœºæƒ…ç»ªæåº¦ä¹è§‚ï¼ŒFOMOæƒ…ç»ªï¼Œä½†åŠ¨èƒ½å‡å¼±ï¼Œèªæ˜èµ„é‡‘ç¦»åœº';
            } else if (currentIndex >= latestWave.wave3End.index) {
                currentWave = 'æµª4';
                pattern = 'ç¬¬4æµªï¼ˆé«˜ä½è°ƒæ•´ï¼‰';
                personality = 'è·åˆ©äº†ç»“ï¼Œéœ‡è¡å‰§çƒˆï¼Œæ´—èµ°ä¸åšå®šè€…ï¼Œä½†ä¸å¦‚æµª2æ·±';
            } else if (currentIndex >= latestWave.wave2End.index) {
                currentWave = 'æµª3';
                pattern = 'ç¬¬3æµªï¼ˆä¸»å‡æµªï¼‰';
                personality = 'æœ€ç‹‚é‡é˜¶æ®µï¼å¤§ä¼—æ¶Œå…¥ï¼Œæˆäº¤é‡æ”¾å¤§ï¼ŒFOMOé«˜æ½®ï¼Œåˆ©æ¶¦æœ€ä¸°åš';
            } else if (currentIndex >= latestWave.wave1End.index) {
                currentWave = 'æµª2';
                pattern = 'ç¬¬2æµªï¼ˆé¦–æ¬¡å›è°ƒï¼‰';
                personality = 'å¸‚åœºå›è°ƒï¼Œæ€€ç–‘è®ºè€…è®¤ä¸ºè¶‹åŠ¿æœªç»“æŸï¼Œä½†ä¸ç ´æµª1èµ·ç‚¹';
            } else {
                currentWave = 'æµª1';
                pattern = 'ç¬¬1æµªï¼ˆå¯åŠ¨ï¼‰';
                personality = 'å°‘æ•°æ•é”æŠ•èµ„è€…ä¹°å…¥ï¼Œå¸‚åœºæƒ…ç»ªä»æ‚²è§‚';
            }
            
            return { currentWave, pattern, personality };
        }
        
        // 9. ç”Ÿæˆäº¤æ˜“ä¿¡å·
        function generateWaveSignal(currentWaveAnalysis, fibonacciAnalysis, volumeConfirmation, divergence) {
            let signal = 'neutral';
            let action = 'è§‚æœ›';
            let confidence = 50;
            let prediction = '';
            let analysis = '';
            let targets = [];
            let stopLoss = null;
            
            const currentWave = currentWaveAnalysis.currentWave;
            
            if (currentWave === 'æµª2') {
                signal = 'buy';
                action = 'æµª2æœ«ç«¯ï¼Œè€ƒè™‘ä¹°å…¥';
                confidence = 70;
                prediction = 'æµª2å›è°ƒç»“æŸï¼Œå³å°†è¿›å…¥æµª3ä¸»å‡æµª';
                analysis = `å½“å‰å¤„äº${currentWave}ï¼Œ${currentWaveAnalysis.personality}ã€‚è¿™æ˜¯è¾ƒå¥½çš„ä¹°å…¥æœºä¼šï¼Œä½†éœ€ç¡®è®¤ä¸ç ´æµª1ä½ç‚¹ã€‚`;
                if (fibonacciAnalysis.targets.length > 0) {
                    targets = fibonacciAnalysis.targets;
                }
            } else if (currentWave === 'æµª3') {
                signal = 'buy';
                action = 'æµª3ä¸­ï¼ŒæŒæœ‰åšå¤š';
                confidence = 85;
                prediction = 'ä¸»å‡æµªè¿›è¡Œä¸­ï¼Œæœ€ä½³ç›ˆåˆ©é˜¶æ®µ';
                analysis = `å½“å‰å¤„äº${currentWave}ï¼Œ${currentWaveAnalysis.personality}ã€‚è¿™æ˜¯åˆ©æ¶¦æœ€ä¸°åšçš„é˜¶æ®µï¼ŒæŒæœ‰å¤šå•ã€‚`;
                if (volumeConfirmation.wave3VolumeExpansion) {
                    confidence += 5;
                    analysis += ' æˆäº¤é‡æ”¾å¤§ç¡®è®¤æµª3å¼ºåŠ¿ã€‚';
                }
            } else if (currentWave === 'æµª4') {
                signal = 'neutral';
                action = 'æµª4è°ƒæ•´ï¼Œå‡ä»“æˆ–è§‚æœ›';
                confidence = 60;
                prediction = 'é«˜ä½éœ‡è¡è°ƒæ•´ï¼Œç­‰å¾…æµª5';
                analysis = `å½“å‰å¤„äº${currentWave}ï¼Œ${currentWaveAnalysis.personality}ã€‚å»ºè®®è·åˆ©äº†ç»“éƒ¨åˆ†ä»“ä½ï¼Œç­‰å¾…æµª5ã€‚`;
            } else if (currentWave === 'æµª5') {
                if (divergence.hasMacdDivergence || divergence.hasRsiDivergence) {
                    signal = 'sell';
                    action = 'æµª5é¡¶èƒŒç¦»ï¼Œå‡†å¤‡å–å‡º';
                    confidence = 80;
                    prediction = 'æµª5å®Œæˆï¼Œè¶‹åŠ¿å³å°†åè½¬';
                    analysis = `å½“å‰å¤„äº${currentWave}ï¼Œ${currentWaveAnalysis.personality}ã€‚`;
                    if (divergence.hasMacdDivergence) {
                        analysis += ' MACDé¡¶èƒŒç¦»ï¼Œ';
                    }
                    if (divergence.hasRsiDivergence) {
                        analysis += ' RSIé¡¶èƒŒç¦»ï¼Œ';
                    }
                    analysis += 'åŠ¨èƒ½è¡°ç«­ï¼Œå»ºè®®é€æ­¥ç¦»åœºã€‚';
                    
                    if (volumeConfirmation.wave5VolumeDivergence) {
                        confidence += 5;
                        analysis += ' æˆäº¤é‡èç¼©ç¡®è®¤èƒŒç¦»ã€‚';
                    }
                } else {
                    signal = 'neutral';
                    action = 'æµª5ä¸­ï¼Œå¯†åˆ‡å…³æ³¨èƒŒç¦»';
                    confidence = 65;
                    prediction = 'æœ€åæ¨åŠ¨é˜¶æ®µï¼Œéšæ—¶å‡†å¤‡ç¦»åœº';
                    analysis = `å½“å‰å¤„äº${currentWave}ï¼Œ${currentWaveAnalysis.personality}ã€‚è™½æœªå‘ç°èƒŒç¦»ï¼Œä½†åº”è°¨æ…ï¼Œéšæ—¶å‡†å¤‡ç¦»åœºã€‚`;
                }
            } else if (currentWave === 'Aæµªè°ƒæ•´') {
                signal = 'sell';
                action = '5æµªå®Œæˆï¼Œè°ƒæ•´æµªå¼€å§‹';
                confidence = 75;
                prediction = 'ABCè°ƒæ•´æµªï¼Œç­‰å¾…Cæµªä½ç‚¹';
                analysis = '5æµªé©±åŠ¨ç»“æŸï¼Œè¿›å…¥è°ƒæ•´æµªã€‚è§‚æœ›æˆ–åšç©ºï¼Œç­‰å¾…Cæµªä½ç‚¹é‡æ–°ä¹°å…¥ã€‚';
            } else {
                signal = 'neutral';
                action = 'è¶‹åŠ¿ä¸æ˜ï¼Œç­‰å¾…ç¡®è®¤';
                confidence = 50;
                prediction = 'ç­‰å¾…æ›´æ¸…æ™°çš„æ³¢æµªç»“æ„';
                analysis = currentWaveAnalysis.pattern + 'ã€‚' + currentWaveAnalysis.personality;
            }
            
            return {
                signal,
                action,
                confidence,
                prediction,
                analysis,
                targets,
                stopLoss
            };
        }
        
        // ç¼ è®ºåˆ†æ
        // ==================== ç¼ è®ºåˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰====================
        function analyzeChanTheory(highs, lows, closes, macdData) {
            if (closes.length < 30) {
                return { 
                    trend: 'æ•°æ®ä¸è¶³', 
                    strength: 0,
                    fenxingCount: 0,
                    biCount: 0,
                    zhongshuCount: 0,
                    buyPoints: [],
                    sellPoints: [],
                    currentZhongshu: null,
                    analysis: 'æ•°æ®ä¸è¶³ï¼Œéœ€è¦è‡³å°‘30æ ¹Kçº¿'
                };
            }
            
            // 1. å¤„ç†Kçº¿åŒ…å«å…³ç³»
            const mergedKlines = processChanIncludeRelationship(highs, lows, closes);
            
            // 2. è¯†åˆ«åˆ†å‹ï¼ˆé¡¶åˆ†å‹å’Œåº•åˆ†å‹ï¼‰
            const fenxings = identifyChanFenxings(mergedKlines);
            
            // 3. è¯†åˆ«ç¬”
            const bis = identifyChanBis(fenxings, mergedKlines);
            
            // 4. è¯†åˆ«ä¸­æ¢
            const zhongshus = identifyChanZhongshu(bis, closes);
            
            // 5. è¯†åˆ«ä¹°å–ç‚¹
            const buyPoints = identifyChanBuyPoints(bis, zhongshus, macdData, closes);
            const sellPoints = identifyChanSellPoints(bis, zhongshus, macdData, closes);
            
            // 6. åˆ†æå½“å‰å¸‚åœºçŠ¶æ€
            const currentState = analyzeChanCurrentState(bis, zhongshus, closes, buyPoints, sellPoints);
            
            // 7. ç”Ÿæˆäº¤æ˜“ä¿¡å·
            const tradingSignal = generateChanTradingSignal(currentState, buyPoints, sellPoints, zhongshus, closes);
            
            return {
                trend: currentState.trend,
                signal: tradingSignal.signal,
                strength: tradingSignal.confidence / 100,
                fenxingCount: fenxings.length,
                biCount: bis.length,
                zhongshuCount: zhongshus.length,
                buyPoints,
                sellPoints,
                currentZhongshu: currentState.currentZhongshu,
                lastBi: bis.length > 0 ? bis[bis.length - 1] : null,
                confidence: tradingSignal.confidence,
                action: tradingSignal.action,
                analysis: tradingSignal.analysis,
                marketPhase: currentState.phase,
                keyLevels: currentState.keyLevels
            };
        }
        
        // 1. å¤„ç†Kçº¿åŒ…å«å…³ç³»
        function processChanIncludeRelationship(highs, lows, closes) {
            if (highs.length === 0) return [];
            
            const merged = [{
                index: 0,
                high: highs[0],
                low: lows[0],
                close: closes[0],
                merged: false
            }];
            
            for (let i = 1; i < highs.length; i++) {
                const current = { index: i, high: highs[i], low: lows[i], close: closes[i] };
                const lastMerged = merged[merged.length - 1];
                
                // åˆ¤æ–­æ˜¯å¦æœ‰åŒ…å«å…³ç³»
                const hasInclude = (current.high <= lastMerged.high && current.low >= lastMerged.low) ||
                                  (current.high >= lastMerged.high && current.low <= lastMerged.low);
                
                if (hasInclude) {
                    // ç¡®å®šè¶‹åŠ¿æ–¹å‘
                    const trend = merged.length >= 2 ? 
                        (merged[merged.length - 1].high > merged[merged.length - 2].high ? 'up' : 'down') : 
                        'up';
                    
                    // æ ¹æ®è¶‹åŠ¿åˆå¹¶Kçº¿
                    if (trend === 'up') {
                        // ä¸Šå‡è¶‹åŠ¿ï¼šå–é«˜é«˜ã€é«˜ä½
                        lastMerged.high = Math.max(lastMerged.high, current.high);
                        lastMerged.low = Math.max(lastMerged.low, current.low);
                        lastMerged.close = current.close;
                        lastMerged.merged = true;
                    } else {
                        // ä¸‹é™è¶‹åŠ¿ï¼šå–ä½é«˜ã€ä½ä½
                        lastMerged.high = Math.min(lastMerged.high, current.high);
                        lastMerged.low = Math.min(lastMerged.low, current.low);
                        lastMerged.close = current.close;
                        lastMerged.merged = true;
                    }
                } else {
                    merged.push(current);
                }
            }
            
            return merged;
        }
        
        // 2. è¯†åˆ«åˆ†å‹
        function identifyChanFenxings(mergedKlines) {
            const fenxings = [];
            
            for (let i = 1; i < mergedKlines.length - 1; i++) {
                const prev = mergedKlines[i - 1];
                const current = mergedKlines[i];
                const next = mergedKlines[i + 1];
                
                // é¡¶åˆ†å‹ï¼šä¸­é—´Kçº¿çš„é«˜ç‚¹å’Œä½ç‚¹éƒ½æ˜¯æœ€é«˜çš„
                if (current.high > prev.high && current.high > next.high &&
                    current.low > prev.low && current.low > next.low) {
                    fenxings.push({
                        type: 'top',
                        index: current.index,
                        price: current.high,
                        kline: current,
                        confirmed: i < mergedKlines.length - 3 // éœ€è¦åç»­ç¡®è®¤
                    });
                }
                // åº•åˆ†å‹ï¼šä¸­é—´Kçº¿çš„é«˜ç‚¹å’Œä½ç‚¹éƒ½æ˜¯æœ€ä½çš„
                else if (current.high < prev.high && current.high < next.high &&
                        current.low < prev.low && current.low < next.low) {
                    fenxings.push({
                        type: 'bottom',
                        index: current.index,
                        price: current.low,
                        kline: current,
                        confirmed: i < mergedKlines.length - 3
                    });
                }
            }
            
            return fenxings;
        }
        
        // 3. è¯†åˆ«ç¬”
        function identifyChanBis(fenxings, mergedKlines) {
            if (fenxings.length < 2) return [];
            
            const bis = [];
            let currentStart = fenxings[0];
            
            for (let i = 1; i < fenxings.length; i++) {
                const fenxing = fenxings[i];
                
                // ç¬”å¿…é¡»ç”±é¡¶åˆ†å‹å’Œåº•åˆ†å‹äº¤æ›¿æ„æˆ
                if (fenxing.type !== currentStart.type) {
                    // è®¡ç®—ç¬”çš„ä»·æ ¼å˜åŒ–
                    const priceChange = Math.abs(fenxing.price - currentStart.price);
                    const percentChange = (priceChange / currentStart.price) * 100;
                    
                    // è‡³å°‘åŒ…å«5æ ¹Kçº¿ï¼Œä¸”ä»·æ ¼å˜åŒ–è¶³å¤Ÿå¤§ï¼ˆè¿‡æ»¤æ¯›åˆºï¼‰
                    const klineCount = Math.abs(fenxing.index - currentStart.index);
                    if (klineCount >= 4 && percentChange >= 0.3) {
                        bis.push({
                            start: currentStart,
                            end: fenxing,
                            direction: currentStart.type === 'bottom' ? 'up' : 'down',
                            priceChange,
                            percentChange,
                            klineCount,
                            strength: Math.min(percentChange * 10, 100)
                        });
                        
                        currentStart = fenxing;
                    } else {
                        // å¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œé€‰æ‹©æ›´æç«¯çš„åˆ†å‹
                        if (fenxing.type === 'top' && fenxing.price > currentStart.price) {
                            currentStart = fenxing;
                        } else if (fenxing.type === 'bottom' && fenxing.price < currentStart.price) {
                            currentStart = fenxing;
                        }
                    }
                } else {
                    // åŒç±»å‹åˆ†å‹ï¼Œå–æ›´æç«¯çš„å€¼
                    if (fenxing.type === 'top' && fenxing.price > currentStart.price) {
                        currentStart = fenxing;
                    } else if (fenxing.type === 'bottom' && fenxing.price < currentStart.price) {
                        currentStart = fenxing;
                    }
                }
            }
            
            return bis;
        }
        
        // 4. è¯†åˆ«ä¸­æ¢
        function identifyChanZhongshu(bis, closes) {
            if (bis.length < 3) return [];
            
            const zhongshus = [];
            
            // è‡³å°‘éœ€è¦ä¸‰ä¸ªè¿ç»­ç¬”å½¢æˆä¸­æ¢
            for (let i = 0; i < bis.length - 2; i++) {
                const bi1 = bis[i];
                const bi2 = bis[i + 1];
                const bi3 = bis[i + 2];
                
                // è·å–ç¬”çš„ä»·æ ¼åŒºé—´
                const bi1High = Math.max(bi1.start.price, bi1.end.price);
                const bi1Low = Math.min(bi1.start.price, bi1.end.price);
                const bi2High = Math.max(bi2.start.price, bi2.end.price);
                const bi2Low = Math.min(bi2.start.price, bi2.end.price);
                const bi3High = Math.max(bi3.start.price, bi3.end.price);
                const bi3Low = Math.min(bi3.start.price, bi3.end.price);
                
                // è®¡ç®—é‡å åŒºé—´
                const overlapHigh = Math.min(bi1High, bi2High, bi3High);
                const overlapLow = Math.max(bi1Low, bi2Low, bi3Low);
                
                // å¦‚æœæœ‰é‡å åŒºé—´ï¼Œå½¢æˆä¸­æ¢
                if (overlapHigh > overlapLow) {
                    const zg = overlapHigh; // ä¸­æ¢ä¸Šè½¨
                    const zd = overlapLow;  // ä¸­æ¢ä¸‹è½¨
                    const zz = (zg + zd) / 2; // ä¸­æ¢ä¸­è½´
                    const range = ((zg - zd) / zz) * 100;
                    
                    // æŸ¥æ‰¾æ˜¯å¦æ˜¯ç°æœ‰ä¸­æ¢çš„å»¶ä¼¸
                    const existingZhongshu = zhongshus.find(z => 
                        !z.ended && Math.abs(z.zg - zg) / zg < 0.05 && Math.abs(z.zd - zd) / zd < 0.05
                    );
                    
                    if (existingZhongshu) {
                        // å»¶ä¼¸ç°æœ‰ä¸­æ¢
                        existingZhongshu.endIndex = i + 2;
                        existingZhongshu.biCount++;
                    } else {
                        // åˆ›å»ºæ–°ä¸­æ¢
                        zhongshus.push({
                            startIndex: i,
                            endIndex: i + 2,
                            zg,
                            zd,
                            zz,
                            range,
                            biCount: 3,
                            level: range < 3 ? 'small' : (range < 8 ? 'medium' : 'large'),
                            ended: false
                        });
                    }
                }
            }
            
            // æ ‡è®°å·²ç»“æŸçš„ä¸­æ¢
            zhongshus.forEach(z => z.ended = true);
            
            return zhongshus;
        }
        
        // 5. è¯†åˆ«ä¹°ç‚¹
        function identifyChanBuyPoints(bis, zhongshus, macdData, closes) {
            const buyPoints = [];
            
            if (bis.length < 3) return buyPoints;
            
            // ç¬¬ä¸€ç±»ä¹°ç‚¹ï¼šèƒŒé©°
            for (let i = 2; i < bis.length; i++) {
                const currentBi = bis[i];
                const prevBi = bis[i - 2]; // å‰ä¸€ä¸ªåŒå‘ç¬”
                
                if (currentBi.direction === 'down' && prevBi.direction === 'down') {
                    // ä»·æ ¼åˆ›æ–°ä½
                    if (currentBi.end.price < prevBi.end.price) {
                        // æ£€æŸ¥MACDèƒŒé©°ï¼ˆå¦‚æœæœ‰MACDæ•°æ®ï¼‰
                        const hasMacdDivergence = checkChanMacdDivergence(
                            prevBi.end.index, 
                            currentBi.end.index, 
                            macdData
                        );
                        
                        if (hasMacdDivergence) {
                            buyPoints.push({
                                type: '1ä¹°',
                                index: currentBi.end.index,
                                price: currentBi.end.price,
                                biIndex: i,
                                confidence: 75,
                                description: 'èƒŒé©°ä¹°ç‚¹ï¼šä»·æ ¼æ–°ä½ä½†MACDä¸åˆ›æ–°ä½'
                            });
                        }
                    }
                }
            }
            
            // ç¬¬äºŒç±»ä¹°ç‚¹ï¼š1ä¹°åå›è°ƒä¸åˆ›æ–°ä½
            buyPoints.forEach(buy1 => {
                if (buy1.type === '1ä¹°') {
                    for (let i = buy1.biIndex + 2; i < bis.length; i++) {
                        const bi = bis[i];
                        if (bi.direction === 'down' && bi.end.price > buy1.price) {
                            buyPoints.push({
                                type: '2ä¹°',
                                index: bi.end.index,
                                price: bi.end.price,
                                biIndex: i,
                                confidence: 85,
                                description: 'ç¬¬äºŒç±»ä¹°ç‚¹ï¼šå›è°ƒä¸ç ´1ä¹°ä½ç‚¹ï¼Œå®‰å…¨æ€§æœ€é«˜'
                            });
                            break;
                        }
                    }
                }
            });
            
            // ç¬¬ä¸‰ç±»ä¹°ç‚¹ï¼šç¦»å¼€ä¸­æ¢åä¸å›åˆ°ä¸­æ¢
            zhongshus.forEach(zhongshu => {
                for (let i = zhongshu.endIndex + 1; i < bis.length; i++) {
                    const bi = bis[i];
                    // å‘ä¸Šçªç ´ä¸­æ¢åå›è°ƒ
                    if (bi.direction === 'down' && bi.start.price > zhongshu.zg) {
                        // å›è°ƒä¸è¿›å…¥ä¸­æ¢
                        if (bi.end.price >= zhongshu.zg) {
                            buyPoints.push({
                                type: '3ä¹°',
                                index: bi.end.index,
                                price: bi.end.price,
                                biIndex: i,
                                zhongshu,
                                confidence: 80,
                                description: 'ç¬¬ä¸‰ç±»ä¹°ç‚¹ï¼šçªç ´ä¸­æ¢åå›è¸©ä¸ç ´ï¼Œä¸»å‡æµªå¯åŠ¨'
                            });
                            break;
                        }
                    }
                }
            });
            
            return buyPoints;
        }
        
        // 6. è¯†åˆ«å–ç‚¹
        function identifyChanSellPoints(bis, zhongshus, macdData, closes) {
            const sellPoints = [];
            
            if (bis.length < 3) return sellPoints;
            
            // ç¬¬ä¸€ç±»å–ç‚¹ï¼šé¡¶èƒŒé©°
            for (let i = 2; i < bis.length; i++) {
                const currentBi = bis[i];
                const prevBi = bis[i - 2];
                
                if (currentBi.direction === 'up' && prevBi.direction === 'up') {
                    // ä»·æ ¼åˆ›æ–°é«˜
                    if (currentBi.end.price > prevBi.end.price) {
                        // æ£€æŸ¥MACDèƒŒé©°
                        const hasMacdDivergence = checkChanMacdDivergence(
                            prevBi.end.index, 
                            currentBi.end.index, 
                            macdData,
                            'top'
                        );
                        
                        if (hasMacdDivergence) {
                            sellPoints.push({
                                type: '1å–',
                                index: currentBi.end.index,
                                price: currentBi.end.price,
                                biIndex: i,
                                confidence: 75,
                                description: 'é¡¶èƒŒé©°å–ç‚¹ï¼šä»·æ ¼æ–°é«˜ä½†MACDä¸åˆ›æ–°é«˜'
                            });
                        }
                    }
                }
            }
            
            // ç¬¬äºŒç±»å–ç‚¹
            sellPoints.forEach(sell1 => {
                if (sell1.type === '1å–') {
                    for (let i = sell1.biIndex + 2; i < bis.length; i++) {
                        const bi = bis[i];
                        if (bi.direction === 'up' && bi.end.price < sell1.price) {
                            sellPoints.push({
                                type: '2å–',
                                index: bi.end.index,
                                price: bi.end.price,
                                biIndex: i,
                                confidence: 85,
                                description: 'ç¬¬äºŒç±»å–ç‚¹ï¼šåå¼¹ä¸ç ´1å–é«˜ç‚¹'
                            });
                            break;
                        }
                    }
                }
            });
            
            // ç¬¬ä¸‰ç±»å–ç‚¹
            zhongshus.forEach(zhongshu => {
                for (let i = zhongshu.endIndex + 1; i < bis.length; i++) {
                    const bi = bis[i];
                    if (bi.direction === 'up' && bi.start.price < zhongshu.zd) {
                        if (bi.end.price <= zhongshu.zd) {
                            sellPoints.push({
                                type: '3å–',
                                index: bi.end.index,
                                price: bi.end.price,
                                biIndex: i,
                                zhongshu,
                                confidence: 80,
                                description: 'ç¬¬ä¸‰ç±»å–ç‚¹ï¼šè·Œç ´ä¸­æ¢ååå¼¹æ— åŠ›'
                            });
                            break;
                        }
                    }
                }
            });
            
            return sellPoints;
        }
        
        // MACDèƒŒé©°æ£€æµ‹
        function checkChanMacdDivergence(prevIndex, currentIndex, macdData, type = 'bottom') {
            if (!macdData || macdData.length === 0) {
                return false; // æ²¡æœ‰MACDæ•°æ®ï¼Œä¸åˆ¤æ–­èƒŒé©°
            }
            
            const prevMacd = macdData[Math.min(prevIndex, macdData.length - 1)];
            const currentMacd = macdData[Math.min(currentIndex, macdData.length - 1)];
            
            if (!prevMacd || !currentMacd) return false;
            
            if (type === 'bottom') {
                // åº•èƒŒé©°ï¼šä»·æ ¼æ–°ä½ï¼ŒMACDæŠ¬é«˜
                return currentMacd > prevMacd;
            } else {
                // é¡¶èƒŒé©°ï¼šä»·æ ¼æ–°é«˜ï¼ŒMACDé™ä½
                return currentMacd < prevMacd;
            }
        }
        
        // 7. åˆ†æå½“å‰å¸‚åœºçŠ¶æ€
        function analyzeChanCurrentState(bis, zhongshus, closes, buyPoints, sellPoints) {
            const currentPrice = closes[closes.length - 1];
            let trend = 'éœ‡è¡';
            let phase = 'è§‚å¯ŸæœŸ';
            let currentZhongshu = null;
            const keyLevels = [];
            
            // æ‰¾åˆ°æœ€è¿‘çš„ä¸­æ¢
            if (zhongshus.length > 0) {
                currentZhongshu = zhongshus[zhongshus.length - 1];
                keyLevels.push({
                    type: 'ä¸­æ¢ä¸Šè½¨',
                    price: currentZhongshu.zg,
                    distance: ((currentZhongshu.zg - currentPrice) / currentPrice * 100).toFixed(2)
                });
                keyLevels.push({
                    type: 'ä¸­æ¢ä¸‹è½¨',
                    price: currentZhongshu.zd,
                    distance: ((currentZhongshu.zd - currentPrice) / currentPrice * 100).toFixed(2)
                });
            }
            
            // åˆ¤æ–­è¶‹åŠ¿
            if (bis.length >= 4) {
                const recentBis = bis.slice(-4);
                const upBis = recentBis.filter(b => b.direction === 'up');
                const downBis = recentBis.filter(b => b.direction === 'down');
                
                if (upBis.length > downBis.length) {
                    trend = 'ä¸Šæ¶¨è¶‹åŠ¿';
                    phase = 'å¤šå¤´';
                } else if (downBis.length > upBis.length) {
                    trend = 'ä¸‹è·Œè¶‹åŠ¿';
                    phase = 'ç©ºå¤´';
                } else {
                    trend = 'éœ‡è¡æ•´ç†';
                    phase = 'ä¸­æ€§';
                }
            }
            
            // åˆ¤æ–­ä»·æ ¼ç›¸å¯¹ä¸­æ¢çš„ä½ç½®
            if (currentZhongshu) {
                if (currentPrice > currentZhongshu.zg) {
                    phase += ' - ä¸­æ¢ä¸Šæ–¹';
                } else if (currentPrice < currentZhongshu.zd) {
                    phase += ' - ä¸­æ¢ä¸‹æ–¹';
                } else {
                    phase += ' - ä¸­æ¢å†…éœ‡è¡';
                }
            }
            
            return {
                trend,
                phase,
                currentZhongshu,
                keyLevels
            };
        }
        
        // 8. ç”Ÿæˆäº¤æ˜“ä¿¡å·
        function generateChanTradingSignal(currentState, buyPoints, sellPoints, zhongshus, closes) {
            let signal = 'neutral';
            let action = 'è§‚æœ›';
            let confidence = 50;
            let analysis = '';
            
            // æŸ¥æ‰¾æœ€è¿‘çš„ä¹°å–ç‚¹
            const recentBuyPoints = buyPoints.filter(p => p.index >= closes.length - 20);
            const recentSellPoints = sellPoints.filter(p => p.index >= closes.length - 20);
            
            if (recentBuyPoints.length > 0) {
                const latestBuy = recentBuyPoints[recentBuyPoints.length - 1];
                signal = 'buy';
                action = latestBuy.type === '2ä¹°' ? 'å¼ºçƒˆä¹°å…¥' : 'è€ƒè™‘ä¹°å…¥';
                confidence = latestBuy.confidence;
                analysis = `å‘ç°${latestBuy.type}ï¼š${latestBuy.description}`;
            } else if (recentSellPoints.length > 0) {
                const latestSell = recentSellPoints[recentSellPoints.length - 1];
                signal = 'sell';
                action = latestSell.type === '2å–' ? 'å¼ºçƒˆå–å‡º' : 'è€ƒè™‘å–å‡º';
                confidence = latestSell.confidence;
                analysis = `å‘ç°${latestSell.type}ï¼š${latestSell.description}`;
            } else {
                // æ²¡æœ‰æ˜ç¡®ä¹°å–ç‚¹ï¼Œæ ¹æ®ä¸­æ¢ä½ç½®åˆ¤æ–­
                if (currentState.currentZhongshu) {
                    const currentPrice = closes[closes.length - 1];
                    const zhongshu = currentState.currentZhongshu;
                    
                    if (currentPrice < zhongshu.zd) {
                        signal = 'buy';
                        action = 'æ¥è¿‘ä¸­æ¢ä¸‹è½¨ï¼Œå¯è€ƒè™‘ä¹°å…¥';
                        confidence = 60;
                        analysis = `ä»·æ ¼åœ¨ä¸­æ¢ä¸‹æ–¹ï¼Œæ¥è¿‘æ”¯æ’‘ä½${zhongshu.zd.toFixed(2)}`;
                    } else if (currentPrice > zhongshu.zg) {
                        signal = 'sell';
                        action = 'æ¥è¿‘ä¸­æ¢ä¸Šè½¨ï¼Œå¯è€ƒè™‘å–å‡º';
                        confidence = 60;
                        analysis = `ä»·æ ¼åœ¨ä¸­æ¢ä¸Šæ–¹ï¼Œæ¥è¿‘é˜»åŠ›ä½${zhongshu.zg.toFixed(2)}`;
                    } else {
                        signal = 'neutral';
                        action = 'ä¸­æ¢å†…éœ‡è¡ï¼Œå»ºè®®è§‚æœ›';
                        confidence = 50;
                        analysis = `ä»·æ ¼åœ¨ä¸­æ¢åŒºé—´å†…éœ‡è¡ï¼Œç­‰å¾…æ–¹å‘é€‰æ‹©`;
                    }
                } else {
                    analysis = `å½“å‰${currentState.trend}ï¼Œæš‚æ— æ˜ç¡®ä¹°å–ç‚¹ï¼Œå»ºè®®ç­‰å¾…`;
                }
            }
            
            return {
                signal,
                action,
                confidence,
                analysis
            };
        }
        
        // å¨ç§‘å¤«åˆ†æ
        // ==================== å¨ç§‘å¤«äº¤æ˜“æ³•ï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰====================
        function analyzeWyckoff(closes, volumes, highs, lows) {
            if (closes.length < 30 || volumes.length < 30) {
                return { 
                    phase: 'æ•°æ®ä¸è¶³', 
                    action: 'è§‚æœ›', 
                    signal: 'neutral',
                    confidence: 0,
                    events: [],
                    supplyDemand: 'æœªçŸ¥'
                };
            }
            
            // 1. æ£€æµ‹å…³é”®å¨ç§‘å¤«äº‹ä»¶
            const events = detectWyckoffEvents(closes, volumes, highs, lows);
            
            // 2. åˆ†æåŠªåŠ›ä¸ç»“æœ
            const effortResult = analyzeEffortVsResult(closes, volumes);
            
            // 3. è®¡ç®—VWAP
            const vwap = calculateVWAP(closes, highs, lows, volumes);
            
            // 4. è¯†åˆ«å½“å‰é˜¶æ®µ
            const phaseAnalysis = identifyWyckoffPhase(events, effortResult, closes, volumes);
            
            // 5. ç”Ÿæˆäº¤æ˜“ä¿¡å·
            const tradingSignal = generateWyckoffSignal(phaseAnalysis, events, effortResult);
            
            return {
                phase: phaseAnalysis.phase,
                subPhase: phaseAnalysis.subPhase,
                action: tradingSignal.action,
                signal: tradingSignal.signal,
                confidence: tradingSignal.confidence,
                supplyDemand: phaseAnalysis.supplyDemand,
                events: events.slice(-5), // æœ€è¿‘5ä¸ªäº‹ä»¶
                effortResult,
                vwap: vwap.current,
                priceVsVWAP: ((closes[closes.length - 1] - vwap.current) / vwap.current * 100).toFixed(2),
                keyLevels: phaseAnalysis.keyLevels,
                analysis: tradingSignal.analysis
            };
        }
        
        // æ£€æµ‹å¨ç§‘å¤«å…³é”®äº‹ä»¶
        function detectWyckoffEvents(closes, volumes, highs, lows) {
            const events = [];
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            
            for (let i = 10; i < closes.length - 2; i++) {
                const currentClose = closes[i];
                const currentVolume = volumes[i];
                const currentHigh = highs[i];
                const currentLow = lows[i];
                const prevClose = closes[i - 1];
                
                // æ£€æµ‹SCï¼ˆæŠ›å”®é«˜æ½®ï¼‰
                const scDetected = detectSellingClimax(
                    i, closes, volumes, highs, lows, avgVolume
                );
                if (scDetected) {
                    events.push({
                        type: 'SC',
                        index: i,
                        price: currentLow,
                        volume: currentVolume,
                        description: 'æŠ›å”®é«˜æ½®ï¼šæé«˜æˆäº¤é‡+å¤§å¹…ä¸‹è·Œ',
                        confidence: scDetected.confidence
                    });
                }
                
                // æ£€æµ‹BCï¼ˆä¹°å…¥é«˜æ½®ï¼‰
                const bcDetected = detectBuyingClimax(
                    i, closes, volumes, highs, lows, avgVolume
                );
                if (bcDetected) {
                    events.push({
                        type: 'BC',
                        index: i,
                        price: currentHigh,
                        volume: currentVolume,
                        description: 'ä¹°å…¥é«˜æ½®ï¼šæé«˜æˆäº¤é‡+å¤§å¹…ä¸Šæ¶¨',
                        confidence: bcDetected.confidence
                    });
                }
                
                // æ£€æµ‹SOSï¼ˆéœ€æ±‚æ˜¾ç°ï¼‰
                if (i > 20) {
                    const sosDetected = detectSignOfStrength(
                        i, closes, volumes, highs, lows, events
                    );
                    if (sosDetected) {
                        events.push({
                            type: 'SOS',
                            index: i,
                            price: currentClose,
                            volume: currentVolume,
                            description: 'éœ€æ±‚æ˜¾ç°ï¼šæ”¾é‡çªç ´éœ‡è¡åŒºé—´',
                            confidence: sosDetected.confidence
                        });
                    }
                }
            }
            
            return events;
        }
        
        // æ£€æµ‹æŠ›å”®é«˜æ½®ï¼ˆSCï¼‰
        function detectSellingClimax(i, closes, volumes, highs, lows, avgVolume) {
            const current = {
                close: closes[i],
                volume: volumes[i],
                high: highs[i],
                low: lows[i]
            };
            
            // SCç‰¹å¾ï¼š
            // 1. æˆäº¤é‡æ˜¯å¹³å‡çš„1.5å€ä»¥ä¸Š
            // 2. ä»·æ ¼å¤§å¹…ä¸‹è·Œï¼ˆ>3%ï¼‰
            // 3. æœ‰é•¿ä¸‹å½±çº¿ï¼ˆå Kçº¿çš„30%ä»¥ä¸Šï¼‰
            
            const volumeSpike = current.volume > avgVolume * 1.5;
            const priceChange = (current.close - closes[i - 1]) / closes[i - 1];
            const priceDrop = priceChange < -0.03;
            
            const candleRange = current.high - current.low;
            const lowerShadow = Math.min(current.close, closes[i - 1]) - current.low;
            const hasLongLowerShadow = candleRange > 0 && (lowerShadow / candleRange) > 0.3;
            
            if (volumeSpike && priceDrop && hasLongLowerShadow) {
                const confidence = Math.min(
                    0.7 + (current.volume / avgVolume - 1.5) * 0.1,
                    0.95
                );
                return { confidence };
            }
            
            return null;
        }
        
        // æ£€æµ‹ä¹°å…¥é«˜æ½®ï¼ˆBCï¼‰
        function detectBuyingClimax(i, closes, volumes, highs, lows, avgVolume) {
            const current = {
                close: closes[i],
                volume: volumes[i],
                high: highs[i],
                low: lows[i]
            };
            
            // BCç‰¹å¾ï¼š
            // 1. æˆäº¤é‡æ˜¯å¹³å‡çš„1.5å€ä»¥ä¸Š
            // 2. ä»·æ ¼å¤§å¹…ä¸Šæ¶¨ï¼ˆ>3%ï¼‰
            // 3. æœ‰é•¿ä¸Šå½±çº¿
            
            const volumeSpike = current.volume > avgVolume * 1.5;
            const priceChange = (current.close - closes[i - 1]) / closes[i - 1];
            const priceRise = priceChange > 0.03;
            
            const candleRange = current.high - current.low;
            const upperShadow = current.high - Math.max(current.close, closes[i - 1]);
            const hasLongUpperShadow = candleRange > 0 && (upperShadow / candleRange) > 0.3;
            
            if (volumeSpike && priceRise && hasLongUpperShadow) {
                const confidence = Math.min(
                    0.7 + (current.volume / avgVolume - 1.5) * 0.1,
                    0.95
                );
                return { confidence };
            }
            
            return null;
        }
        
        // æ£€æµ‹éœ€æ±‚æ˜¾ç°ï¼ˆSOSï¼‰
        function detectSignOfStrength(i, closes, volumes, highs, lows, events) {
            // éœ€è¦å…ˆæœ‰SCäº‹ä»¶
            const recentSC = events.filter(e => e.type === 'SC' && i - e.index < 20 && i - e.index > 0);
            if (recentSC.length === 0) return null;
            
            const lastSC = recentSC[recentSC.length - 1];
            const scPrice = lastSC.price;
            
            // SOSç‰¹å¾ï¼š
            // 1. ä»·æ ¼çªç ´éœ‡è¡åŒºé—´ä¸Šæ²¿
            // 2. æˆäº¤é‡æ”¾å¤§
            // 3. å¼ºåŠ¿ä¸Šæ¶¨ï¼ˆ>2%ï¼‰
            
            const avgRecentVolume = volumes.slice(i - 10, i).reduce((a, b) => a + b, 0) / 10;
            const volumeIncrease = volumes[i] > avgRecentVolume * 1.3;
            
            const priceChange = (closes[i] - closes[i - 1]) / closes[i - 1];
            const strongRise = priceChange > 0.02;
            
            const rangeHigh = Math.max(...closes.slice(lastSC.index, i));
            const breakout = closes[i] > rangeHigh * 1.01;
            
            if (volumeIncrease && strongRise && breakout) {
                const confidence = Math.min(
                    0.75 + (volumes[i] / avgRecentVolume - 1.3) * 0.05,
                    0.9
                );
                return { confidence };
            }
            
            return null;
        }
        
        // åŠªåŠ›ä¸ç»“æœåˆ†æ
        function analyzeEffortVsResult(closes, volumes) {
            const recentPeriod = 10;
            const recentCloses = closes.slice(-recentPeriod);
            const recentVolumes = volumes.slice(-recentPeriod);
            
            // è®¡ç®—ä»·æ ¼å˜åŒ–ï¼ˆç»“æœï¼‰
            const priceChange = Math.abs(
                (recentCloses[recentCloses.length - 1] - recentCloses[0]) / recentCloses[0]
            );
            
            // è®¡ç®—æˆäº¤é‡ï¼ˆåŠªåŠ›ï¼‰
            const totalVolume = recentVolumes.reduce((a, b) => a + b, 0);
            const avgVolume = volumes.slice(-30).reduce((a, b) => a + b, 0) / 30;
            const volumeRatio = totalVolume / (avgVolume * recentPeriod);
            
            // åŠªåŠ›ä¸ç»“æœçš„æ¯”ç‡
            const effortResultRatio = volumeRatio / (priceChange * 100 + 0.01);
            
            let divergence = false;
            let description = '';
            let signal = 'neutral';
            
            if (effortResultRatio > 3) {
                divergence = true;
                description = 'åŠªåŠ›>ç»“æœï¼šæˆäº¤é‡å¤§ä½†ä»·æ ¼å‡ ä¹ä¸åŠ¨ï¼Œè¶‹åŠ¿å¯èƒ½åè½¬';
                signal = 'reversal';
            } else if (effortResultRatio < 0.5) {
                divergence = true;
                description = 'åŠªåŠ›<ç»“æœï¼šä»·æ ¼å¤§åŠ¨ä½†æˆäº¤é‡å°ï¼Œè¶‹åŠ¿è™šå¼±';
                signal = 'weak';
            } else {
                description = 'åŠªåŠ›ä¸ç»“æœåŒ¹é…ï¼Œè¶‹åŠ¿å¥åº·';
                signal = 'healthy';
            }
            
            return {
                divergence,
                effortResultRatio: effortResultRatio.toFixed(2),
                volumeRatio: volumeRatio.toFixed(2),
                priceChange: (priceChange * 100).toFixed(2) + '%',
                description,
                signal
            };
        }
        
        // è®¡ç®—VWAPï¼ˆæˆäº¤é‡åŠ æƒå¹³å‡ä»·ï¼‰
        function calculateVWAP(closes, highs, lows, volumes) {
            let cumulativeTPV = 0; // ç´¯è®¡å…¸å‹ä»·æ ¼Ã—æˆäº¤é‡
            let cumulativeVolume = 0;
            
            const period = Math.min(20, closes.length);
            
            for (let i = closes.length - period; i < closes.length; i++) {
                const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
                cumulativeTPV += typicalPrice * volumes[i];
                cumulativeVolume += volumes[i];
            }
            
            const vwap = cumulativeVolume > 0 ? cumulativeTPV / cumulativeVolume : closes[closes.length - 1];
            
            return {
                current: vwap,
                period
            };
        }
        
        // è¯†åˆ«å¨ç§‘å¤«é˜¶æ®µ
        function identifyWyckoffPhase(events, effortResult, closes, volumes) {
            const recentEvents = events.slice(-10);
            const scEvents = recentEvents.filter(e => e.type === 'SC');
            const bcEvents = recentEvents.filter(e => e.type === 'BC');
            const sosEvents = recentEvents.filter(e => e.type === 'SOS');
            
            let phase = 'ç›˜æ•´é˜¶æ®µ';
            let subPhase = '';
            let supplyDemand = 'ä¾›éœ€å¹³è¡¡';
            let keyLevels = {};
            
            // è¯†åˆ«å¸ç­¹é˜¶æ®µ
            if (scEvents.length > 0 && sosEvents.length === 0) {
                phase = 'å¸ç­¹é˜¶æ®µï¼ˆAccumulationï¼‰';
                const lastSC = scEvents[scEvents.length - 1];
                
                if (sosEvents.length === 0) {
                    subPhase = 'SC-ARé˜¶æ®µï¼ˆæŠ›å”®é«˜æ½®åï¼‰';
                } else {
                    subPhase = 'SOSåï¼ˆéœ€æ±‚ç¡®è®¤ï¼‰';
                }
                
                supplyDemand = 'ä¸»åŠ›å¸ç­¹ï¼Œä¾›åº”æ¯ç«­';
                keyLevels = {
                    scLevel: lastSC.price,
                    description: 'SCä½ç‚¹æ˜¯å…³é”®æ”¯æ’‘'
                };
            }
            // è¯†åˆ«æ´¾å‘é˜¶æ®µ
            else if (bcEvents.length > 0) {
                phase = 'æ´¾å‘é˜¶æ®µï¼ˆDistributionï¼‰';
                const lastBC = bcEvents[bcEvents.length - 1];
                
                subPhase = 'BC-UTADé˜¶æ®µï¼ˆä¹°å…¥é«˜æ½®åï¼‰';
                supplyDemand = 'ä¸»åŠ›æ´¾å‘ï¼Œéœ€æ±‚è¡°ç«­';
                keyLevels = {
                    bcLevel: lastBC.price,
                    description: 'BCé«˜ç‚¹æ˜¯å…³é”®é˜»åŠ›'
                };
            }
            // è¯†åˆ«ä¸Šå‡é˜¶æ®µ
            else if (sosEvents.length > 0) {
                phase = 'ä¸Šå‡é˜¶æ®µï¼ˆMarkupï¼‰';
                subPhase = 'SOSåä¸»å‡æµª';
                supplyDemand = 'éœ€æ±‚ä¸»å¯¼';
            }
            // æ ¹æ®ä»·æ ¼å’Œæˆäº¤é‡åˆ¤æ–­
            else {
                const recentPriceChange = (closes[closes.length - 1] - closes[closes.length - 20]) / closes[closes.length - 20];
                const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
                const recentAvgVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
                const volumeRatio = recentAvgVolume / avgVolume;
                
                if (recentPriceChange > 0.05 && volumeRatio > 1.2) {
                    phase = 'ä¸Šå‡é˜¶æ®µï¼ˆMarkupï¼‰';
                    supplyDemand = 'éœ€æ±‚æ—ºç››';
                } else if (recentPriceChange < -0.05 && volumeRatio > 1.2) {
                    phase = 'ä¸‹è·Œé˜¶æ®µï¼ˆMarkdownï¼‰';
                    supplyDemand = 'ä¾›åº”è¿‡å‰©';
                } else if (Math.abs(recentPriceChange) < 0.02) {
                    phase = 'ç›˜æ•´é˜¶æ®µ';
                    supplyDemand = 'ä¾›éœ€å¹³è¡¡';
                }
            }
            
            return {
                phase,
                subPhase,
                supplyDemand,
                keyLevels
            };
        }
        
        // ç”Ÿæˆå¨ç§‘å¤«äº¤æ˜“ä¿¡å·
        function generateWyckoffSignal(phaseAnalysis, events, effortResult) {
            let signal = 'neutral';
            let action = 'è§‚æœ›';
            let confidence = 0.5;
            let analysis = '';
            
            const recentEvents = events.slice(-5);
            const phase = phaseAnalysis.phase;
            
            // å¸ç­¹é˜¶æ®µåçš„SOSæ˜¯å¼ºçƒˆä¹°å…¥ä¿¡å·
            const hasSOS = recentEvents.some(e => e.type === 'SOS');
            const hasSC = recentEvents.some(e => e.type === 'SC');
            
            if (phase.includes('å¸ç­¹') && hasSOS) {
                signal = 'buy';
                action = 'ç§¯æä¹°å…¥ï¼ˆSOSç¡®è®¤éœ€æ±‚ï¼‰';
                confidence = 0.85;
                analysis = `${phase}ï¼Œå·²å‡ºç°SOSï¼ˆéœ€æ±‚æ˜¾ç°ï¼‰ä¿¡å·ï¼Œè¿™æ˜¯é«˜æ¦‚ç‡çš„ä¹°å…¥æœºä¼šã€‚å»ºè®®ï¼šåœ¨å›è°ƒåˆ°æ”¯æ’‘ä½æ—¶åˆ†æ‰¹å»ºä»“ã€‚`;
            } else if (phase.includes('å¸ç­¹') && hasSC) {
                signal = 'buy';
                action = 'é€¢ä½å¸çº³ï¼ˆSCåç­‰å¾…STï¼‰';
                confidence = 0.7;
                analysis = `${phase}ï¼Œå·²å‡ºç°SCï¼ˆæŠ›å”®é«˜æ½®ï¼‰ï¼Œç­‰å¾…äºŒæ¬¡æµ‹è¯•ï¼ˆSTï¼‰æˆåŠŸåæ˜¯ç†æƒ³çš„ä¹°å…¥æ—¶æœºã€‚`;
            } else if (phase.includes('æ´¾å‘')) {
                signal = 'sell';
                action = 'å‡ä»“æˆ–åšç©º';
                confidence = 0.75;
                analysis = `${phase}ï¼Œä¸»åŠ›åœ¨é«˜ä½æ´¾å‘ï¼Œå»ºè®®é€æ­¥å‡ä»“æˆ–ç­‰å¾…è·Œç ´æ”¯æ’‘ååšç©ºã€‚`;
            } else if (phase.includes('ä¸Šå‡')) {
                signal = 'buy';
                action = 'æŒæœ‰æˆ–å›è°ƒåŠ ä»“';
                confidence = 0.7;
                analysis = `${phase}ï¼Œè¶‹åŠ¿å‘ä¸Šï¼ŒæŒæœ‰ç°æœ‰ä»“ä½ï¼Œæˆ–ç­‰å¾…å›è°ƒåˆ°æ”¯æ’‘ä½åŠ ä»“ã€‚`;
            } else if (phase.includes('ä¸‹è·Œ')) {
                signal = 'sell';
                action = 'ç©ºä»“è§‚æœ›';
                confidence = 0.7;
                analysis = `${phase}ï¼Œè¶‹åŠ¿å‘ä¸‹ï¼Œå»ºè®®ç©ºä»“è§‚æœ›ï¼Œç­‰å¾…å¸ç­¹è¿¹è±¡ã€‚`;
            } else {
                signal = 'neutral';
                action = 'ç­‰å¾…æ˜ç¡®ä¿¡å·';
                confidence = 0.5;
                analysis = `${phase}ï¼Œå¸‚åœºå¤„äºå¹³è¡¡çŠ¶æ€ï¼Œç­‰å¾…çªç ´æ–¹å‘ã€‚å…³æ³¨æˆäº¤é‡å˜åŒ–ã€‚`;
            }
            
            // åŠªåŠ›ä¸ç»“æœåˆ†æè°ƒæ•´
            if (effortResult.divergence && effortResult.signal === 'reversal') {
                confidence = Math.max(confidence - 0.15, 0.3);
                analysis += ` âš ï¸ ${effortResult.description}`;
            }
            
            return {
                signal,
                action,
                confidence: Math.min(confidence, 0.95),
                analysis: `${phaseAnalysis.supplyDemand}ã€‚${analysis}`
            };
        }

        // ==================== æ˜¾ç¤ºæŠ€æœ¯æŒ‡æ ‡ ====================
        function displayIndicators(indicators) {
            const section = document.getElementById('indicatorsSection');
            section.innerHTML = '';

            // MAå‡çº¿
            if (indicators.MA) {
                const maCard = createIndicatorCard('MAå‡çº¿', 'neutral', [
                    { label: 'MA7', value: indicators.MA.MA7?.toFixed(2) || '-' },
                    { label: 'MA30', value: indicators.MA.MA30?.toFixed(2) || '-' },
                    { label: 'MA60', value: indicators.MA.MA60?.toFixed(2) || '-' },
                    { label: 'MA120', value: indicators.MA.MA120?.toFixed(2) || '-' },
                    { label: 'MA240', value: indicators.MA.MA240?.toFixed(2) || '-' }
                ]);
                section.appendChild(maCard);
            }

            // MACD
            if (indicators.MACD) {
                const signal = indicators.MACD.MACD > 0 ? 'buy' : 'sell';
                const macdCard = createIndicatorCard('MACD', signal, [
                    { label: 'DIF', value: indicators.MACD.DIF.toFixed(4) },
                    { label: 'DEA', value: indicators.MACD.DEA.toFixed(4) },
                    { label: 'MACD', value: indicators.MACD.MACD.toFixed(4) },
                    { label: 'ä¿¡å·', value: indicators.MACD.signal }
                ]);
                section.appendChild(macdCard);
            }

            // RSI
            if (indicators.RSI) {
                let signal = 'neutral';
                if (indicators.RSI > 70) signal = 'sell';
                else if (indicators.RSI < 30) signal = 'buy';
                
                const rsiCard = createIndicatorCard('RSI', signal, [
                    { label: 'RSI(14)', value: indicators.RSI.toFixed(2) },
                    { label: 'çŠ¶æ€', value: indicators.RSI > 70 ? 'è¶…ä¹°' : indicators.RSI < 30 ? 'è¶…å–' : 'æ­£å¸¸' }
                ]);
                section.appendChild(rsiCard);
            }

            // å¸ƒæ—å¸¦
            if (indicators.BOLL) {
                const currentPrice = priceData[currentSymbol]?.price || 0;
                let signal = 'neutral';
                if (currentPrice > indicators.BOLL.upper) signal = 'sell';
                else if (currentPrice < indicators.BOLL.lower) signal = 'buy';
                
                const bollCard = createIndicatorCard('å¸ƒæ—å¸¦', signal, [
                    { label: 'ä¸Šè½¨', value: indicators.BOLL.upper.toFixed(2) },
                    { label: 'ä¸­è½¨', value: indicators.BOLL.middle.toFixed(2) },
                    { label: 'ä¸‹è½¨', value: indicators.BOLL.lower.toFixed(2) }
                ]);
                section.appendChild(bollCard);
            }

            // KDJ
            if (indicators.KDJ) {
                let signal = 'neutral';
                if (indicators.KDJ.K > 80) signal = 'sell';
                else if (indicators.KDJ.K < 20) signal = 'buy';
                
                const kdjCard = createIndicatorCard('KDJ', signal, [
                    { label: 'Kå€¼', value: indicators.KDJ.K.toFixed(2) },
                    { label: 'Då€¼', value: indicators.KDJ.D.toFixed(2) },
                    { label: 'Jå€¼', value: indicators.KDJ.J.toFixed(2) }
                ]);
                section.appendChild(kdjCard);
            }

            // VOLæˆäº¤é‡
            if (indicators.VOL) {
                const volCard = createIndicatorCard('VOLæˆäº¤é‡', indicators.VOL.signal, [
                    { label: 'å½“å‰é‡', value: formatVolume(indicators.VOL.currentVolume) },
                    { label: 'å¹³å‡é‡', value: formatVolume(indicators.VOL.avgVolume) },
                    { label: 'é‡æ¯”', value: indicators.VOL.volumeRatio.toFixed(2) + 'x' },
                    { label: 'çŠ¶æ€', value: indicators.VOL.status }
                ]);
                section.appendChild(volCard);
            }
        }

        function formatVolume(vol) {
            if (vol >= 1e9) return (vol / 1e9).toFixed(2) + 'B';
            if (vol >= 1e6) return (vol / 1e6).toFixed(2) + 'M';
            if (vol >= 1e3) return (vol / 1e3).toFixed(2) + 'K';
            return vol.toFixed(2);
        }

        function createIndicatorCard(name, signal, details) {
            const card = document.createElement('div');
            card.className = 'indicator-card';
            
            const signalText = signal === 'buy' ? 'ä¹°å…¥' : signal === 'sell' ? 'å–å‡º' : 'ä¸­æ€§';
            
            card.innerHTML = `
                <div class="indicator-header">
                    <div class="indicator-name">${name}</div>
                    <div class="indicator-signal ${signal}">${signalText}</div>
                </div>
                <div class="indicator-details">
                    ${details.map(d => `
                        <div class="indicator-row">
                            <span class="indicator-label">${d.label}:</span>
                            <span class="indicator-value">${d.value}</span>
                        </div>
                    `).join('')}
                </div>
            `;
            
            return card;
        }

        // ==================== ç”Ÿæˆç»¼åˆäº¤æ˜“å»ºè®® ====================
        function generateComprehensiveRecommendation(indicators, fibonacci, elliottWave, chanTheory, wyckoff, currentPrice, timeframe) {
            // è®¡ç®—å„éƒ¨åˆ†è¯„åˆ†
            let indicatorScore = 50;
            let fibonacciScore = 50;
            let elliottScore = 50;
            let chanScore = 50;
            let wyckoffScore = 50;
            
            // æŠ€æœ¯æŒ‡æ ‡è¯„åˆ†ï¼ˆåŒ…å«VOLï¼‰
            if (indicators.MACD && indicators.MACD.DIF > 0) indicatorScore += 10;
            else if (indicators.MACD && indicators.MACD.DIF < 0) indicatorScore -= 10;
            
            if (indicators.RSI) {
                if (indicators.RSI < 30) indicatorScore += 15;
                else if (indicators.RSI > 70) indicatorScore -= 15;
                else if (indicators.RSI > 50) indicatorScore += 5;
                else indicatorScore -= 5;
            }
            
            if (indicators.KDJ) {
                if (indicators.KDJ.K < 20) indicatorScore += 10;
                else if (indicators.KDJ.K > 80) indicatorScore -= 10;
            }

            if (indicators.VOL) {
                if (indicators.VOL.signal === 'buy') indicatorScore += 8;
                else if (indicators.VOL.signal === 'sell') indicatorScore -= 5;
            }
            
            // æ–æ³¢é‚£å¥‘è¯„åˆ†
            if (fibonacci) {
                if (fibonacci.signal === 'buy') fibonacciScore += 20;
                else if (fibonacci.signal === 'sell') fibonacciScore -= 20;
            }
            
            // æ³¢æµªç†è®ºè¯„åˆ†
            if (elliottWave) {
                if (elliottWave.signal === 'buy') elliottScore += elliottWave.confidence * 30;
                else if (elliottWave.signal === 'sell') elliottScore -= elliottWave.confidence * 30;
            }
            
            // ç¼ è®ºè¯„åˆ†
            if (chanTheory) {
                if (chanTheory.signal === 'buy') chanScore += chanTheory.strength * 40;
                else if (chanTheory.signal === 'sell') chanScore -= chanTheory.strength * 40;
            }
            
            // å¨ç§‘å¤«è¯„åˆ†
            if (wyckoff) {
                if (wyckoff.signal === 'buy') wyckoffScore += 25;
                else if (wyckoff.signal === 'sell') wyckoffScore -= 25;
            }
            
            // åŠ¨æ€æƒé‡è®¡ç®—ï¼ˆæ ¹æ®é€‰æ‹©çš„ç†è®ºï¼‰
            let weights = { indicator: 0.4, fibonacci: 0, elliott: 0, chan: 0, wyckoff: 0 };
            let theoryCount = 0;
            
            if (fibonacci) { weights.fibonacci = 1; theoryCount++; }
            if (elliottWave) { weights.elliott = 1; theoryCount++; }
            if (chanTheory) { weights.chan = 1; theoryCount++; }
            if (wyckoff) { weights.wyckoff = 1; theoryCount++; }
            
            // å¦‚æœé€‰æ‹©äº†ç†è®ºï¼ŒæŒ‡æ ‡å 40%ï¼Œç†è®ºå¹³åˆ†60%
            // å¦‚æœæ²¡é€‰ç†è®ºï¼ŒæŒ‡æ ‡å 100%
            if (theoryCount > 0) {
                const theoryWeight = 0.6 / theoryCount;
                weights.fibonacci *= theoryWeight;
                weights.elliott *= theoryWeight;
                weights.chan *= theoryWeight;
                weights.wyckoff *= theoryWeight;
            } else {
                weights.indicator = 1.0;
            }
            
            // ç»¼åˆè¯„åˆ†ï¼ˆåŠ¨æ€åŠ æƒå¹³å‡ï¼‰
            const totalScore = (
                indicatorScore * weights.indicator +
                fibonacciScore * weights.fibonacci +
                elliottScore * weights.elliott +
                chanScore * weights.chan +
                wyckoffScore * weights.wyckoff
            );
            
            // åˆ¤æ–­äº¤æ˜“æ–¹å‘
            let direction = '';
            let confidence = '';
            let timeframeText = {
                '5m': '5åˆ†é’Ÿ',
                '15m': '15åˆ†é’Ÿ',
                '1h': '1å°æ—¶',
                '4h': '4å°æ—¶',
                '1d': '1å¤©'
            }[timeframe] || timeframe;
            
            if (totalScore >= 70) {
                direction = 'å¼ºçƒˆåšå¤šï¼ˆä¹°å…¥ï¼‰';
                confidence = 'é«˜';
            } else if (totalScore >= 55) {
                direction = 'åšå¤šï¼ˆä¹°å…¥ï¼‰';
                confidence = 'ä¸­';
            } else if (totalScore <= 30) {
                direction = 'å¼ºçƒˆåšç©ºï¼ˆå–å‡ºï¼‰';
                confidence = 'é«˜';
            } else if (totalScore <= 45) {
                direction = 'åšç©ºï¼ˆå–å‡ºï¼‰';
                confidence = 'ä¸­';
            } else {
                direction = 'è§‚æœ›';
                confidence = 'ä¸å»ºè®®äº¤æ˜“';
            }
            
            // è®¡ç®—æ­¢æŸæ­¢ç›ˆ
            const stopLossPercent = direction.includes('å¤š') ? -0.03 : 0.03;
            const takeProfitPercent = direction.includes('å¤š') ? 0.05 : -0.05;
            
            const stopLoss = currentPrice * (1 + stopLossPercent);
            const takeProfit = currentPrice * (1 + takeProfitPercent);
            
            return {
                score: Math.max(0, Math.min(100, totalScore)),
                direction,
                confidence,
                stopLoss,
                takeProfit,
                timeframe: timeframeText,
                indicatorScore,
                fibonacciScore,
                elliottScore,
                chanScore,
                wyckoffScore
            };
        }
        
        // ==================== ç”Ÿæˆäº¤æ˜“å»ºè®®ï¼ˆæ—§ç‰ˆï¼Œä¿ç•™å…¼å®¹ï¼‰ ====================
        function generateRecommendation(indicators, currentPrice) {
            let score = 50;
            
            // åŸºäºå„æŒ‡æ ‡è®¡ç®—ç»¼åˆè¯„åˆ†
            if (indicators.MACD && indicators.MACD.DIF > 0) score += 10;
            else if (indicators.MACD && indicators.MACD.DIF < 0) score -= 10;
            
            if (indicators.RSI) {
                if (indicators.RSI < 30) score += 15;
                else if (indicators.RSI > 70) score -= 15;
            }
            
            if (indicators.KDJ) {
                if (indicators.KDJ.K < 20) score += 10;
                else if (indicators.KDJ.K > 80) score -= 10;
            }
            
            score = Math.max(0, Math.min(100, score));
            
            let direction = 'è§‚æœ›';
            let confidence = 'ä½';
            
            if (score > 65) {
                direction = 'åšå¤šï¼ˆä¹°å…¥ï¼‰';
                confidence = 'é«˜';
            } else if (score > 55) {
                direction = 'åšå¤šï¼ˆä¹°å…¥ï¼‰';
                confidence = 'ä¸­';
            } else if (score < 35) {
                direction = 'åšç©ºï¼ˆå–å‡ºï¼‰';
                confidence = 'é«˜';
            } else if (score < 45) {
                direction = 'åšç©ºï¼ˆå–å‡ºï¼‰';
                confidence = 'ä¸­';
            }
            
            return {
                score: score,
                direction: direction,
                confidence: confidence,
                stopLoss: direction.includes('å¤š') ? currentPrice * 0.95 : currentPrice * 1.05,
                takeProfit: direction.includes('å¤š') ? currentPrice * 1.08 : currentPrice * 0.92
            };
        }

        function displayRecommendation(rec) {
            const section = document.getElementById('recommendationSection');
            section.style.display = 'block';
            
            const scoreClass = rec.score > 60 ? 'high' : rec.score > 40 ? 'medium' : 'low';
            
            section.innerHTML = `
                <div class="recommendation-header">
                    <div class="recommendation-title">ğŸ“ˆ ç»¼åˆäº¤æ˜“å»ºè®®</div>
                    <div class="score-badge ${scoreClass}">${rec.score.toFixed(0)}/100</div>
                </div>
                <div class="recommendation-grid">
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">äº¤æ˜“æ–¹å‘</div>
                        <div class="recommendation-item-value" style="color: ${rec.direction.includes('å¤š') ? 'var(--green)' : rec.direction.includes('ç©º') ? 'var(--red)' : 'var(--yellow)'}">
                            ${rec.direction}
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å¯ä¿¡åº¦</div>
                        <div class="recommendation-item-value">${rec.confidence}</div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å»ºè®®æ­¢æŸä½</div>
                        <div class="recommendation-item-value" style="color: var(--red)">
                            $${formatPrice(rec.stopLoss)}
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å»ºè®®æ­¢ç›ˆä½</div>
                        <div class="recommendation-item-value" style="color: var(--green)">
                            $${formatPrice(rec.takeProfit)}
                        </div>
                    </div>
                </div>
                <div class="risk-warning">
                    <div class="risk-warning-title">âš ï¸ é£é™©æç¤º</div>
                    <div class="risk-warning-content">
                        â€¢ æœ¬åˆ†æä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®<br>
                        â€¢ æ•°å­—è´§å¸å¸‚åœºé«˜åº¦æ³¢åŠ¨ï¼Œè¯·è°¨æ…æŠ•èµ„<br>
                        â€¢ è¯·æ ¹æ®è‡ªèº«é£é™©æ‰¿å—èƒ½åŠ›è®¾ç½®æ­¢æŸ<br>
                        â€¢ å¸‚åœºæœ‰é£é™©ï¼ŒæŠ•èµ„éœ€è°¨æ…
                    </div>
                </div>
            `;
        }

        // æ˜¾ç¤ºç»¼åˆåˆ†æç»“æœï¼ˆæ ¹æ®é€‰æ‹©çš„ç†è®ºæ˜¾ç¤ºï¼‰
        function displayComprehensiveRecommendation(rec, indicators, fibonacci, elliottWave, chanTheory, wyckoff, riskReward, goldenPoints, divergenceAnalysis) {
            const section = document.getElementById('recommendationSection');
            section.style.display = 'block';
            
            const scoreClass = rec.score > 60 ? 'high' : rec.score > 40 ? 'medium' : 'low';
            const getSignalColor = (signal) => {
                if (signal === 'buy') return 'var(--green)';
                if (signal === 'sell') return 'var(--red)';
                return 'var(--yellow)';
            };
            
            // æ„å»ºè¯„åˆ†æ„æˆHTMLï¼ˆåªæ˜¾ç¤ºé€‰æ‹©çš„ç†è®ºï¼‰
            let scoreCardsHTML = `
                <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">æŠ€æœ¯æŒ‡æ ‡</div>
                    <div style="font-size: 18px; font-weight: 600;">${rec.indicatorScore.toFixed(1)}/100</div>
                </div>
            `;
            
            if (fibonacci) {
                scoreCardsHTML += `
                    <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">æ–æ³¢é‚£å¥‘</div>
                        <div style="font-size: 18px; font-weight: 600;">${rec.fibonacciScore.toFixed(1)}/100</div>
                    </div>
                `;
            }
            if (elliottWave) {
                scoreCardsHTML += `
                    <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">æ³¢æµªç†è®º</div>
                        <div style="font-size: 18px; font-weight: 600;">${rec.elliottScore.toFixed(1)}/100</div>
                    </div>
                `;
            }
            if (chanTheory) {
                scoreCardsHTML += `
                    <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">ç¼ è®º</div>
                        <div style="font-size: 18px; font-weight: 600;">${rec.chanScore.toFixed(1)}/100</div>
                    </div>
                `;
            }
            if (wyckoff) {
                scoreCardsHTML += `
                    <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">å¨ç§‘å¤«</div>
                        <div style="font-size: 18px; font-weight: 600;">${rec.wyckoffScore.toFixed(1)}/100</div>
                    </div>
                `;
            }
            
            section.innerHTML = `
                <div class="recommendation-header">
                    <div class="recommendation-title">ğŸ“Š ä¸“ä¸šæŠ€æœ¯åˆ†ææŠ¥å‘Š - ${currentSymbol} (${rec.timeframe})</div>
                    <div class="score-badge ${scoreClass}">${rec.score.toFixed(0)}/100</div>
                </div>
                
                <!-- ä¿¡å·ä¸€è‡´æ€§å’Œåˆ†æ­§æç¤º -->
                ${divergenceAnalysis ? `
                <div style="background: ${divergenceAnalysis.hasDivergence ? 'linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, var(--bg-secondary) 100%)' : 'linear-gradient(135deg, rgba(14, 203, 129, 0.15) 0%, var(--bg-secondary) 100%)'}; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid ${divergenceAnalysis.hasDivergence ? '#ffc107' : 'var(--green)'};">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                        <div>
                            <h3 style="margin: 0 0 8px 0; font-size: 18px; color: var(--text-primary);">
                                ${divergenceAnalysis.hasDivergence ? 'âš ï¸ æ£€æµ‹åˆ°ä¿¡å·åˆ†æ­§' : 'âœ… ä¿¡å·å¼ºçƒˆä¸€è‡´'}
                            </h3>
                            <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">
                                ${divergenceAnalysis.consistency}
                            </div>
                        </div>
                        <div style="text-align: center; padding: 16px; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">ä¿¡å·å¼ºåº¦</div>
                            <div style="font-size: 28px; font-weight: bold; color: var(--accent);">${divergenceAnalysis.signalStrength}%</div>
                        </div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 6px; margin-bottom: 12px;">
                        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ“ å½“å‰å¸‚åœºçŠ¶æ€</div>
                        <div style="font-size: 15px; color: var(--text-primary); line-height: 1.6;">${divergenceAnalysis.marketState}</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 6px;">
                        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ’¡ æ“ä½œå»ºè®®</div>
                        <div style="font-size: 15px; color: var(--text-primary); font-weight: 600; line-height: 1.6;">${divergenceAnalysis.actionAdvice}</div>
                    </div>
                </div>
                ` : ''}
                
                <!-- ç»¼åˆè¯„åˆ†è¯¦æƒ… -->
                <div style="background: var(--bg-secondary); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">ğŸ¯ ç»¼åˆè¯„åˆ†æ„æˆ</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px;">
                        ${scoreCardsHTML}
                    </div>
                </div>
                
                <!-- äº¤æ˜“å»ºè®® -->
                <div class="recommendation-grid" style="margin-bottom: 24px;">
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">äº¤æ˜“æ–¹å‘</div>
                        <div class="recommendation-item-value" style="color: ${rec.direction.includes('å¤š') ? 'var(--green)' : rec.direction.includes('ç©º') ? 'var(--red)' : 'var(--yellow)'}">
                            ${rec.direction}
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å¯ä¿¡åº¦</div>
                        <div class="recommendation-item-value">${rec.confidence}</div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å»ºè®®æ­¢æŸä½</div>
                        <div class="recommendation-item-value" style="color: var(--red)">
                            $${formatPrice(rec.stopLoss)}
                        </div>
                    </div>
                    <div class="recommendation-item">
                        <div class="recommendation-item-title">å»ºè®®æ­¢ç›ˆä½</div>
                        <div class="recommendation-item-value" style="color: var(--green)">
                            $${formatPrice(rec.takeProfit)}
                        </div>
                    </div>
                </div>
                
                <!-- é£é™©æ”¶ç›Šæ¯”åˆ†æ -->
                ${riskReward ? `
                <div class="risk-reward-card">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">âš–ï¸ é£é™©æ”¶ç›Šæ¯”åˆ†æ</h3>
                    <div class="risk-reward-grid">
                        <div class="risk-reward-item">
                            <div class="risk-reward-label">é£é™©æ”¶ç›Šæ¯”</div>
                            <div class="risk-reward-value" style="color: ${parseFloat(riskReward.ratio) >= 2 ? 'var(--green)' : parseFloat(riskReward.ratio) >= 1.5 ? 'var(--yellow)' : 'var(--red)'}">
                                1:${riskReward.ratio}
                            </div>
                        </div>
                        <div class="risk-reward-item">
                            <div class="risk-reward-label">æ½œåœ¨é£é™©</div>
                            <div class="risk-reward-value" style="color: var(--red)">
                                $${riskReward.risk} (${riskReward.riskPercent}%)
                            </div>
                        </div>
                        <div class="risk-reward-item">
                            <div class="risk-reward-label">æ½œåœ¨æ”¶ç›Š</div>
                            <div class="risk-reward-value" style="color: var(--green)">
                                $${riskReward.reward} (${riskReward.rewardPercent}%)
                            </div>
                        </div>
                        <div class="risk-reward-item">
                            <div class="risk-reward-label">æœŸæœ›æ”¶ç›Š</div>
                            <div class="risk-reward-value" style="color: ${parseFloat(riskReward.expectedReturn) >= 0 ? 'var(--green)' : 'var(--red)'}">
                                ${riskReward.expectedReturn}%
                            </div>
                        </div>
                    </div>
                    <div class="position-advice">
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ’¼ ä»“ä½å»ºè®®</div>
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">${riskReward.positionAdvice}</div>
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                <span style="font-size: 12px; color: var(--text-secondary);">å»ºè®®ä»“ä½å æ¯”</span>
                                <span style="font-size: 16px; font-weight: 600; color: var(--accent)">${riskReward.positionSize}%</span>
                            </div>
                            <div style="width: 100%; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                <div style="width: ${riskReward.positionSize}%; height: 100%; background: linear-gradient(90deg, var(--accent) 0%, var(--blue) 100%); border-radius: 4px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <!-- é»„é‡‘ä¹°å–ç‚¹è¯†åˆ« -->
                ${goldenPoints && goldenPoints.length > 0 ? `
                <div class="risk-reward-card">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">â­ é»„é‡‘ä¹°å–ç‚¹è¯†åˆ«</h3>
                    <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 16px;">
                        åŸºäºæŠ€æœ¯æŒ‡æ ‡å…±æŒ¯ï¼Œåœ¨è¿‘æœŸKçº¿ä¸­å‘ç° ${goldenPoints.length} ä¸ªé«˜æ¦‚ç‡äº¤æ˜“æœºä¼š
                    </div>
                    <div style="display: grid; gap: 12px;">
                        ${goldenPoints.slice(-5).reverse().map((point, idx) => `
                            <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; border-left: 4px solid ${point.type === 'buy' ? 'var(--green)' : 'var(--red)'};">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 24px;">${point.type === 'buy' ? 'ğŸŸ¢' : 'ğŸ”´'}</span>
                                        <span style="font-size: 14px; font-weight: 600; color: ${point.type === 'buy' ? 'var(--green)' : 'var(--red)'}">
                                            ${point.type === 'buy' ? 'é»„é‡‘ä¹°ç‚¹' : 'é»„é‡‘å–ç‚¹'}
                                        </span>
                                    </div>
                                    <div style="padding: 4px 12px; background: var(--bg-tertiary); border-radius: 4px; font-size: 12px; font-weight: 600; color: var(--accent);">
                                        ${point.confidence}%
                                    </div>
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">
                                    ä»·æ ¼: <span style="font-weight: 600; color: var(--text-primary);">$${formatPrice(point.price)}</span>
                                </div>
                                <div style="font-size: 12px; color: var(--text-tertiary);">
                                    ä¿¡å·åŸå› : ${point.reasons}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                
                <!-- äº¤æ˜“ç†è®ºåˆ†æï¼ˆåªæ˜¾ç¤ºé€‰æ‹©çš„ï¼‰ -->
                ${fibonacci ? `
                <div style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">ğŸ“ æ–æ³¢é‚£å¥‘åˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰</h3>
                    <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; border-left: 4px solid ${getSignalColor(fibonacci.signal)};">
                        <!-- ä¸»è¦åˆ†æå’Œäº¤æ˜“åŒºåŸŸ -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">å½“å‰ä½ç½®</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${fibonacci.tradingZone || 'å¸¸è§„åŒºåŸŸ'}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">ç½®ä¿¡åº¦</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${fibonacci.confidence > 0.7 ? 'var(--green)' : fibonacci.confidence > 0.5 ? 'var(--yellow)' : 'var(--red)'}">
                                    ${(fibonacci.confidence * 100).toFixed(0)}%
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 12px; font-size: 14px; color: var(--text-secondary);">${fibonacci.analysis}</div>
                        
                        <!-- å…±æŒ¯åˆ†æï¼ˆå¦‚æœæœ‰ï¼‰ -->
                        ${fibonacci.resonance && fibonacci.resonance.count > 0 ? `
                        <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, var(--bg-tertiary) 100%); padding: 12px; border-radius: 6px; margin-bottom: 16px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-size: 18px;">âš¡</span>
                                <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">å¤šé‡å…±æŒ¯æ£€æµ‹</span>
                                <span style="padding: 2px 8px; background: rgba(255, 215, 0, 0.2); border-radius: 12px; font-size: 11px; font-weight: 600; color: #ffd700;">
                                    ${fibonacci.resonance.count}é‡å…±æŒ¯
                                </span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                                ${fibonacci.resonance.description}
                            </div>
                            ${fibonacci.resonance.levels && fibonacci.resonance.levels.length > 0 ? `
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 6px;">
                                å…±æŒ¯æ°´å¹³ï¼š${fibonacci.resonance.levels.join(', ')}
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                        
                        <!-- æ”¯æ’‘é˜»åŠ›ä½ -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 12px; color: var(--text-tertiary); margin-bottom: 8px; font-weight: 600;">ğŸ“ æ”¯æ’‘ä½</div>
                                ${fibonacci.support && fibonacci.support.length > 0 ? 
                                    fibonacci.support.map(s => `
                                        <div style="font-size: 13px; color: var(--green); margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                            <span>${s.level}</span>
                                            <div style="text-align: right;">
                                                <span style="font-weight: 600;">$${formatPrice(s.price)}</span>
                                                <span style="font-size: 10px; color: var(--text-tertiary); margin-left: 4px;">${s.distance || ''}</span>
                                                ${s.importance && s.importance >= 8 ? '<span style="margin-left: 4px; color: #ffd700;">â­</span>' : ''}
                                            </div>
                                        </div>
                                    `).join('') 
                                    : '<div style="font-size: 13px; color: var(--text-secondary);">æš‚æ— </div>'}
                            </div>
                            <div>
                                <div style="font-size: 12px; color: var(--text-tertiary); margin-bottom: 8px; font-weight: 600;">ğŸ¯ é˜»åŠ›ä½</div>
                                ${fibonacci.resistance && fibonacci.resistance.length > 0 ? 
                                    fibonacci.resistance.map(r => `
                                        <div style="font-size: 13px; color: var(--red); margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                            <span>${r.level}</span>
                                            <div style="text-align: right;">
                                                <span style="font-weight: 600;">$${formatPrice(r.price)}</span>
                                                <span style="font-size: 10px; color: var(--text-tertiary); margin-left: 4px;">${r.distance || ''}</span>
                                                ${r.importance && r.importance >= 8 ? '<span style="margin-left: 4px; color: #ffd700;">â­</span>' : ''}
                                            </div>
                                        </div>
                                    `).join('')
                                    : '<div style="font-size: 13px; color: var(--text-secondary);">æš‚æ— </div>'}
                            </div>
                        </div>
                        
                        <!-- æ‰©å±•ä½ï¼ˆå¦‚æœæœ‰ï¼‰ -->
                        ${fibonacci.extensions ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px;">
                            <div style="font-size: 12px; color: var(--text-tertiary); margin-bottom: 8px; font-weight: 600;">ğŸš€ æ‰©å±•ä½ï¼ˆæ­¢ç›ˆç›®æ ‡ï¼‰</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px;">
                                ${Object.entries(fibonacci.extensions).slice(0, 3).map(([level, price]) => `
                                    <div style="text-align: center; padding: 6px; background: var(--bg-secondary); border-radius: 4px;">
                                        <div style="font-size: 10px; color: var(--text-tertiary);">${level}</div>
                                        <div style="font-size: 12px; font-weight: 600; color: var(--accent);">$${formatPrice(price)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- è¶‹åŠ¿ä¿¡æ¯ -->
                        <div style="margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px; color: var(--text-secondary);">
                            ${fibonacci.isUptrend ? 'ğŸ“ˆ ä¸Šå‡è¶‹åŠ¿' : 'ğŸ“‰ ä¸‹é™è¶‹åŠ¿'} | 
                            æ³¢æ®µåŒºé—´: $${formatPrice(fibonacci.low)} - $${formatPrice(fibonacci.high)}
                            ${fibonacci.range ? ` | å¹…åº¦: $${formatPrice(fibonacci.range)}` : ''}
                        </div>
                    </div>
                </div>
                ` : ''}
                
                ${elliottWave ? `
                <div style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">ğŸŒŠ æ³¢æµªç†è®ºåˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰</h3>
                    <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; border-left: 4px solid ${getSignalColor(elliottWave.signal)};">
                        
                        <!-- æ ¸å¿ƒåˆ†æå’Œç½®ä¿¡åº¦ -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">å½“å‰æ³¢æµª</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${elliottWave.currentWave || elliottWave.pattern}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">ç½®ä¿¡åº¦</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${elliottWave.confidence > 70 ? 'var(--green)' : elliottWave.confidence > 50 ? 'var(--yellow)' : 'var(--red)'}">
                                    ${elliottWave.confidence}%
                                </div>
                            </div>
                        </div>
                        
                        <!-- æ³¢æµªä¸ªæ€§æè¿° -->
                        ${elliottWave.wavePersonality ? `
                        <div style="margin-bottom: 16px; padding: 12px; background: linear-gradient(135deg, rgba(${elliottWave.signal === 'buy' ? '14, 203, 129' : elliottWave.signal === 'sell' ? '246, 70, 93' : '255, 193, 7'}, 0.1) 0%, var(--bg-tertiary) 100%); border-radius: 6px;">
                            <div style="font-size: 12px; color: var(--text-tertiary); margin-bottom: 6px;">ğŸ­ æ³¢æµªä¸ªæ€§ï¼ˆå¸‚åœºå¿ƒç†ï¼‰</div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">${elliottWave.wavePersonality}</div>
                        </div>
                        ` : ''}
                        
                        <!-- æ“ä½œå»ºè®® -->
                        <div style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                ${elliottWave.action || elliottWave.pattern}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                ${elliottWave.analysis}
                            </div>
                        </div>
                        
                        <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                            <div style="text-align: center; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">è¯†åˆ«æ³¢æµªæ•°</div>
                                <div style="font-size: 18px; font-weight: 600; color: var(--accent);">${elliottWave.waves ? elliottWave.waves.length : 0}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">æå€¼ç‚¹æ•°</div>
                                <div style="font-size: 18px; font-weight: 600; color: var(--accent);">${elliottWave.waveCount || 0}</div>
                            </div>
                        </div>
                        
                        <!-- æ–æ³¢é‚£å¥‘æ¯”ç‡å…³ç³» -->
                        ${elliottWave.fibonacciRelations && elliottWave.fibonacciRelations.length > 0 ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ“Š æ³¢æµªæ¯”ç‡åˆ†æ</div>
                            ${elliottWave.fibonacciRelations.map(rel => `
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                    <span>æµª3/æµª1: <span style="color: ${rel.is3Extended ? 'var(--green)' : 'var(--yellow)'}; font-weight: 600;">${rel.wave3to1}</span></span>
                                    ${rel.is3Extended ? ' <span style="color: var(--green);">âœ“ å»¶é•¿æµª</span>' : ''}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                    <span>æµª5/æµª1: <span style="color: ${rel.is5Proportional ? 'var(--green)' : 'var(--yellow)'}; font-weight: 600;">${rel.wave5to1}</span></span>
                                    ${rel.is5Proportional ? ' <span style="color: var(--green);">âœ“ æ¯”ä¾‹åè°ƒ</span>' : ''}
                                </div>
                                <div style="font-size: 11px; color: var(--text-tertiary);">
                                    è´¨é‡è¯„çº§: ${rel.quality === 'excellent' ? 'â­â­â­â­â­ ä¼˜ç§€' : 'â­â­â­ è‰¯å¥½'}
                                </div>
                            `).join('')}
                        </div>
                        ` : ''}
                        
                        <!-- ç›®æ ‡ä½ -->
                        ${elliottWave.fibonacciTargets && elliottWave.fibonacciTargets.length > 0 ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ¯ æ³¢æµªç›®æ ‡ä½</div>
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                ${elliottWave.fibonacciTargets.map(target => `
                                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 12px;">
                                        <span style="color: var(--text-secondary);">${target.level}</span>
                                        <div style="text-align: right;">
                                            <span style="color: var(--text-primary); font-weight: 600; margin-right: 8px;">$${formatPrice(target.price)}</span>
                                            <span style="color: ${target.probability === 'high' ? 'var(--green)' : 'var(--yellow)'}; font-size: 11px;">${target.probability === 'high' ? 'é«˜æ¦‚ç‡' : 'ä¸­æ¦‚ç‡'}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- èƒŒç¦»æ£€æµ‹ -->
                        ${elliottWave.divergence && (elliottWave.divergence.hasMacdDivergence || elliottWave.divergence.hasRsiDivergence) ? `
                        <div style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, var(--bg-tertiary) 100%); padding: 12px; border-radius: 6px; border: 1px solid rgba(255, 193, 7, 0.3);">
                            <div style="font-size: 13px; font-weight: 600; color: #ffc107; margin-bottom: 8px;">âš ï¸ æ£€æµ‹åˆ°èƒŒç¦»ä¿¡å·</div>
                            <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                                ${elliottWave.divergence.hasMacdDivergence ? 'â€¢ MACDèƒŒç¦»<br>' : ''}
                                ${elliottWave.divergence.hasRsiDivergence ? 'â€¢ RSIèƒŒç¦»<br>' : ''}
                                ${elliottWave.divergence.type === 'bearish' ? '<span style="color: var(--red);">çœ‹è·ŒèƒŒç¦»ï¼Œè¶‹åŠ¿å¯èƒ½åè½¬</span>' : ''}
                                ${elliottWave.divergence.type === 'bullish' ? '<span style="color: var(--green);">çœ‹æ¶¨èƒŒç¦»ï¼Œåº•éƒ¨å¯èƒ½å½¢æˆ</span>' : ''}
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- æˆäº¤é‡ç¡®è®¤ -->
                        ${elliottWave.volumeProfile && elliottWave.volumeProfile.hasData ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-top: 12px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ“ˆ æˆäº¤é‡ç¡®è®¤</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${elliottWave.volumeProfile.wave3VolumeExpansion ? 'â€¢ <span style="color: var(--green);">æµª3æ”¾é‡ âœ“</span><br>' : 'â€¢ æµª3æœªæ˜æ˜¾æ”¾é‡<br>'}
                                ${elliottWave.volumeProfile.wave5VolumeDivergence ? 'â€¢ <span style="color: var(--yellow);">æµª5ç¼©é‡ï¼ˆèƒŒç¦»ï¼‰âš ï¸</span>' : ''}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}
                
                ${chanTheory ? `
                <div style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">ğŸ“ˆ ç¼ è®ºåˆ†æï¼ˆä¸“ä¸šå¢å¼ºç‰ˆï¼‰</h3>
                    <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; border-left: 4px solid ${getSignalColor(chanTheory.signal)};">
                        
                        <!-- æ ¸å¿ƒåˆ†æå’Œç½®ä¿¡åº¦ -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">å¸‚åœºé˜¶æ®µ</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${chanTheory.marketPhase || chanTheory.trend}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">ç½®ä¿¡åº¦</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${chanTheory.confidence > 70 ? 'var(--green)' : chanTheory.confidence > 50 ? 'var(--yellow)' : 'var(--red)'}">
                                    ${chanTheory.confidence}%
                                </div>
                            </div>
                        </div>
                        
                        <!-- æ ¸å¿ƒä¿¡å·åˆ†æ -->
                        <div style="margin-bottom: 16px; padding: 12px; background: linear-gradient(135deg, rgba(${chanTheory.signal === 'buy' ? '14, 203, 129' : chanTheory.signal === 'sell' ? '246, 70, 93' : '255, 193, 7'}, 0.1) 0%, var(--bg-tertiary) 100%); border-radius: 6px;">
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                ${chanTheory.action || chanTheory.trend}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                ${chanTheory.analysis}
                            </div>
                        </div>
                        
                        <!-- ç¼ è®ºæ ¸å¿ƒæ„ä»¶ç»Ÿè®¡ -->
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                            <div style="text-align: center; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">åˆ†å‹æ•°</div>
                                <div style="font-size: 18px; font-weight: 600; color: var(--accent);">${chanTheory.fenxingCount || 0}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">ç¬”æ•°</div>
                                <div style="font-size: 18px; font-weight: 600; color: var(--accent);">${chanTheory.biCount || 0}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">ä¸­æ¢æ•°</div>
                                <div style="font-size: 18px; font-weight: 600; color: var(--accent);">${chanTheory.zhongshuCount || 0}</div>
                            </div>
                        </div>
                        
                        <!-- å½“å‰ä¸­æ¢ä¿¡æ¯ -->
                        ${chanTheory.currentZhongshu ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ¯ å½“å‰ä¸­æ¢</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                                <div><span style="color: var(--text-tertiary);">ä¸­æ¢ä¸Šè½¨ï¼š</span><span style="color: var(--red); font-weight: 600;">$${formatPrice(chanTheory.currentZhongshu.zg)}</span></div>
                                <div><span style="color: var(--text-tertiary);">ä¸­æ¢ä¸‹è½¨ï¼š</span><span style="color: var(--green); font-weight: 600;">$${formatPrice(chanTheory.currentZhongshu.zd)}</span></div>
                                <div><span style="color: var(--text-tertiary);">ä¸­è½´ä»·ï¼š</span><span style="color: var(--text-primary);">$${formatPrice(chanTheory.currentZhongshu.zz)}</span></div>
                                <div><span style="color: var(--text-tertiary);">çº§åˆ«ï¼š</span><span style="color: var(--text-primary);">${chanTheory.currentZhongshu.level === 'small' ? 'å°çº§åˆ«' : chanTheory.currentZhongshu.level === 'medium' ? 'ä¸­çº§åˆ«' : 'å¤§çº§åˆ«'}</span></div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- ä¹°å–ç‚¹è¯†åˆ« -->
                        ${chanTheory.buyPoints && chanTheory.buyPoints.length > 0 ? `
                        <div style="background: linear-gradient(135deg, rgba(14, 203, 129, 0.1) 0%, var(--bg-tertiary) 100%); padding: 12px; border-radius: 6px; margin-bottom: 12px; border: 1px solid rgba(14, 203, 129, 0.3);">
                            <div style="font-size: 13px; font-weight: 600; color: var(--green); margin-bottom: 8px;">
                                ğŸŸ¢ å‘ç°ä¹°ç‚¹ä¿¡å· (${chanTheory.buyPoints.length}ä¸ª)
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                ${chanTheory.buyPoints.slice(-3).map(point => `
                                    <div style="background: var(--bg-secondary); padding: 8px; border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                            <span style="font-size: 12px; font-weight: 600; color: var(--green);">${point.type}</span>
                                            <span style="font-size: 11px; color: var(--text-tertiary);">$${formatPrice(point.price)}</span>
                                        </div>
                                        <div style="font-size: 11px; color: var(--text-secondary);">${point.description}</div>
                                        <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 4px;">ç½®ä¿¡åº¦: ${point.confidence}%</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        ${chanTheory.sellPoints && chanTheory.sellPoints.length > 0 ? `
                        <div style="background: linear-gradient(135deg, rgba(246, 70, 93, 0.1) 0%, var(--bg-tertiary) 100%); padding: 12px; border-radius: 6px; margin-bottom: 12px; border: 1px solid rgba(246, 70, 93, 0.3);">
                            <div style="font-size: 13px; font-weight: 600; color: var(--red); margin-bottom: 8px;">
                                ğŸ”´ å‘ç°å–ç‚¹ä¿¡å· (${chanTheory.sellPoints.length}ä¸ª)
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                ${chanTheory.sellPoints.slice(-3).map(point => `
                                    <div style="background: var(--bg-secondary); padding: 8px; border-radius: 4px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                            <span style="font-size: 12px; font-weight: 600; color: var(--red);">${point.type}</span>
                                            <span style="font-size: 11px; color: var(--text-tertiary);">$${formatPrice(point.price)}</span>
                                        </div>
                                        <div style="font-size: 11px; color: var(--text-secondary);">${point.description}</div>
                                        <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 4px;">ç½®ä¿¡åº¦: ${point.confidence}%</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- å…³é”®ä»·ä½ -->
                        ${chanTheory.keyLevels && chanTheory.keyLevels.length > 0 ? `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ğŸ“ å…³é”®ä»·ä½</div>
                            <div style="display: flex; flex-direction: column; gap: 6px; font-size: 12px;">
                                ${chanTheory.keyLevels.map(level => `
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">${level.type}</span>
                                        <div style="text-align: right;">
                                            <span style="color: var(--text-primary); font-weight: 600; margin-right: 8px;">$${formatPrice(level.price)}</span>
                                            <span style="color: ${parseFloat(level.distance) > 0 ? 'var(--red)' : 'var(--green)'}; font-size: 11px;">(${level.distance}%)</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}
                
                ${wyckoff ? `
                <div style="margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; color: var(--text-primary);">ğŸ“Š å¨ç§‘å¤«äº¤æ˜“æ³•åˆ†æ</h3>
                    <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; border-left: 4px solid ${getSignalColor(wyckoff.signal)};">
                        <div style="margin-bottom: 8px;"><span style="color: var(--text-secondary);">å¸‚åœºé˜¶æ®µï¼š</span><span style="color: var(--text-primary); font-weight: 600;">${wyckoff.phase}</span></div>
                        <div style="margin-bottom: 8px;"><span style="color: var(--text-secondary);">ä¾›éœ€å…³ç³»ï¼š</span><span style="color: var(--text-primary);">${wyckoff.supplyDemand}</span></div>
                        <div style="margin-bottom: 8px;"><span style="color: var(--text-secondary);">æ“ä½œå»ºè®®ï¼š</span><span style="color: ${wyckoff.signal === 'buy' ? 'var(--green)' : wyckoff.signal === 'sell' ? 'var(--red)' : 'var(--yellow)'}; font-weight: 600;">${wyckoff.action}</span></div>
                        <div style="font-size: 13px; color: var(--text-tertiary); margin-top: 12px;">${wyckoff.analysis}</div>
                    </div>
                </div>
                ` : ''}
                
                <!-- é£é™©æç¤º -->
                <div class="risk-warning">
                    <div class="risk-warning-title">âš ï¸ é£é™©æç¤º</div>
                    <div class="risk-warning-content">
                        â€¢ æœ¬åˆ†æåŸºäº${rec.timeframe}å‘¨æœŸæ•°æ®ï¼Œä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®<br>
                        â€¢ ä¸åŒå‘¨æœŸå¯èƒ½å¾—å‡ºä¸åŒç»“è®ºï¼Œå»ºè®®ç»“åˆå¤šå‘¨æœŸåˆ†æ<br>
                        â€¢ æ•°å­—è´§å¸å¸‚åœºé«˜åº¦æ³¢åŠ¨ï¼Œè¯·ä¸¥æ ¼è®¾ç½®æ­¢æŸ<br>
                        â€¢ è¯·æ ¹æ®è‡ªèº«é£é™©æ‰¿å—èƒ½åŠ›å’Œèµ„é‡‘ç®¡ç†åŸåˆ™è¿›è¡Œäº¤æ˜“<br>
                        â€¢ å¸‚åœºæœ‰é£é™©ï¼ŒæŠ•èµ„éœ€è°¨æ…
                    </div>
                </div>
            `;
        }

        // ==================== æ·»åŠ è‡ªå®šä¹‰å¸ç§ ====================
        function addCustomCoin() {
            const input = document.getElementById('coinInput');
            let inputSymbol = input.value.trim().toUpperCase();
            
            if (!inputSymbol) {
                alert('è¯·è¾“å…¥å¸ç§ç¬¦å·ï¼');
                return;
            }
            
            // ç¡®å®šå®Œæ•´çš„äº¤æ˜“å¯¹ç¬¦å·
            let fullSymbol = inputSymbol;
            if (!inputSymbol.includes('USDT') && !inputSymbol.includes('BTC') && !inputSymbol.includes('ETH')) {
                fullSymbol = inputSymbol + 'USDT';
            }
            
            // çŸ­ç¬¦å·ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
            let shortSymbol = inputSymbol.replace('USDT', '').replace('BTC', '').replace('ETH', '');
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if (SYMBOLS.includes(shortSymbol)) {
                alert('è¯¥å¸ç§å·²åœ¨ç›‘æ§åˆ—è¡¨ä¸­ï¼');
                input.value = '';
                return;
            }
            
            // éªŒè¯å¸ç§æ˜¯å¦å­˜åœ¨
            fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${fullSymbol}`)
                .then(response => {
                    if (!response.ok) throw new Error('å¸ç§ä¸å­˜åœ¨');
                    return response.json();
                })
                .then(data => {
                    // æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨
                    SYMBOLS.push(shortSymbol);
                    SYMBOL_MAP[shortSymbol] = fullSymbol;
                    
                    // åˆå§‹åŒ–æ•°æ®
                    priceData[shortSymbol] = {
                        price: parseFloat(data.lastPrice),
                        change: parseFloat(data.priceChangePercent),
                        high: parseFloat(data.highPrice),
                        low: parseFloat(data.lowPrice),
                        volume: parseFloat(data.volume)
                    };
                    
                    // é‡æ–°è¿æ¥WebSocketä»¥åŒ…å«æ–°å¸ç§
                    if (ws) {
                        ws.close();
                    }
                    connectWebSocket();
                    
                    // æ›´æ–°UI
                    updateCoinList();
                    
                    // åŠ è½½Kçº¿æ•°æ®
                    loadKlineData(shortSymbol, currentTimeframe);
                    
                    // æ¸…ç©ºè¾“å…¥æ¡†
                    input.value = '';
                    
                    // é€‰æ‹©æ–°æ·»åŠ çš„å¸ç§
                    selectCoin(shortSymbol);
                    
                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    alert(`æˆåŠŸæ·»åŠ  ${shortSymbol} (${fullSymbol}) åˆ°ç›‘æ§åˆ—è¡¨ï¼`);
                })
                .catch(error => {
                    alert('æ·»åŠ å¤±è´¥ï¼šå¸ç§ä¸å­˜åœ¨æˆ–ç½‘ç»œé”™è¯¯ï¼\nè¯·æ£€æŸ¥å¸ç§ç¬¦å·æ˜¯å¦æ­£ç¡®ï¼ˆå¦‚ï¼šETHã€BNBã€PEPEï¼‰');
                    console.error('æ·»åŠ å¸ç§å¤±è´¥:', error);
                });
        }
        
        function handleCoinInputEnter(event) {
            if (event.key === 'Enter') {
                addCustomCoin();
            }
        }

        // ==================== æ¨¡æ€æ¡†æ§åˆ¶ ====================
        function showAnalysisOptions() {
            document.getElementById('analysisModal').classList.add('show');
        }

        function closeAnalysisModal() {
            document.getElementById('analysisModal').classList.remove('show');
        }

        function toggleCheckbox(element, theoryName) {
            const checkbox = element.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                element.classList.add('checked');
            } else {
                element.classList.remove('checked');
            }
        }

        function getSelectedTheories() {
            return {
                fibonacci: document.getElementById('check-fibonacci').checked,
                elliott: document.getElementById('check-elliott').checked,
                chan: document.getElementById('check-chan').checked,
                wyckoff: document.getElementById('check-wyckoff').checked
            };
        }

        function startAnalysis() {
            closeAnalysisModal();
            performAnalysis();
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('analysisModal');
            if (e.target === modal) {
                closeAnalysisModal();
            }
            
            const scanModal = document.getElementById('scanModal');
            if (e.target === scanModal) {
                closeScanModal();
            }
        });

        // ==================== å¸‚åœºæœºä¼šæ‰«æ ====================
        async function scanMarketOpportunities() {
            // æ‰“å¼€æ¨¡æ€æ¡†
            const modal = document.getElementById('scanModal');
            modal.style.display = 'block';
            
            // æ˜¾ç¤ºè¿›åº¦
            document.getElementById('scanProgress').style.display = 'block';
            document.getElementById('scanResults').innerHTML = '';
            
            // è·å–æ‰€æœ‰äº¤æ˜“å¯¹ï¼ˆ100+å¸ç§ï¼‰
            const allSymbols = [
                // ä¸»æµå¸ï¼ˆå‰20ï¼‰
                'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT',
                'ADAUSDT', 'DOGEUSDT', 'MATICUSDT', 'DOTUSDT', 'AVAXUSDT',
                'LINKUSDT', 'ATOMUSDT', 'UNIUSDT', 'LTCUSDT', 'ETCUSDT',
                'XLMUSDT', 'FILUSDT', 'TRXUSDT', 'AAVEUSDT', 'ALGOUSDT',
                
                // DeFi & Layer2ï¼ˆ20ä¸ªï¼‰
                'ARBUSDT', 'OPUSDT', 'INJUSDT', 'SUIUSDT', 'APTUSDT',
                'RUNEUSDT', 'STXUSDT', 'IMXUSDT', 'MINAUSDT', 'MKRUSDT',
                'SNXUSDT', 'COMPUSDT', 'CRVUSDT', '1INCHUSDT', 'SUSHIUSDT',
                'YFIUSDT', 'BALUSDT', 'ZRXUSDT', 'RENUSDT', 'LRCUSDT',
                
                // çƒ­é—¨å±±å¯¨å¸ï¼ˆ30ä¸ªï¼‰
                'SANDUSDT', 'MANAUSDT', 'NEARUSDT', 'LDOUSDT', 'TIAUSDT',
                'FTMUSDT', 'ICPUSDT', 'VETUSDT', 'HBARUSDT', 'THETAUSDT',
                'EOSUSDT', 'AXSUSDT', 'FLOWUSDT', 'CHZUSDT', 'ENJUSDT',
                'GALAUSDT', 'GRTUSDT', 'QNTUSDT', 'FLOKIUSDT', 'PEPEUSDT',
                '1000SHIBUSDT', 'JASMYUSDT', 'MAGIUSDT', 'APEUSDT', 'RENDERUSDT',
                'BLURUSDT', 'WLDUSDT', 'MASKUSDT', 'AGIXUSDT', 'FETUSDT',
                
                // æ–°å…´é¡¹ç›®ï¼ˆ30ä¸ªï¼‰
                'SEIUSDT', 'CYBERUSDT', 'PENDLEUSDT', 'ARKMUSDT', 'JTOUSDT',
                'UMAUSDT', 'IDUSDT', 'ORBSUSDT', 'RADUSDT', 'CFXUSDT',
                'ACHUSDT', 'BELUSDT', 'SFPUSDT', 'PERPUSDT', 'DYDXUSDT',
                'GMXUSDT', 'RDNTUSDT', 'LOOMUSDT', 'MAVUSDT', 'EDUUSDT',
                'COMBOUSDT', 'LEVERUSDT', 'AMBUSDT', 'PHBUSDT', 'HOOKUSDT',
                'MAGICUSDT', 'HFTUSDT', 'POLYXUSDT', 'GASUSDT', 'GLMRUSDT',
                
                // ç¨³å®šæˆé•¿å¸ï¼ˆ20ä¸ªï¼‰
                'KSMUSDT', 'ZECUSDT', 'DASHUSDT', 'WAVESUSDT', 'KAVAUSDT',
                'ONTUSDT', 'ZILUSDT', 'RVNUSDT', 'CELOUSDT', 'BATUSDT',
                'IOSTUSDT', 'ZENUSDT', 'OMGUSDT', 'BANDUSDT', 'STORJUSDT',
                'SKLUSDT', 'CTKUSDT', 'ANKRUSDT', 'KNCUSDT', 'OCEANUSDT'
            ];
            
            const opportunities = [];
            let processed = 0;
            
            // å¤šå‘¨æœŸæ‰«æ
            const timeframes = [
                { interval: '15m', name: '15åˆ†é’Ÿ' },
                { interval: '1h', name: '1å°æ—¶' },
                { interval: '4h', name: '4å°æ—¶' }
            ];
            
            // é€ä¸ªæ‰«æ
            for (const symbol of allSymbols) {
                try {
                    // æ›´æ–°è¿›åº¦
                    processed++;
                    document.getElementById('scanProgressText').textContent = 
                        `å·²æ‰«æ: ${processed}/${allSymbols.length} (${symbol})`;
                    
                    // æ‰«æå¤šä¸ªå‘¨æœŸ
                    for (const tf of timeframes) {
                        try {
                            // è·å–Kçº¿æ•°æ®
                            const response = await fetch(
                                `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${tf.interval}&limit=100`
                            );
                            const data = await response.json();
                            
                            if (!data || data.length < 30) continue;
                            
                            const klines = data.map(k => ({
                                time: k[0],
                                open: parseFloat(k[1]),
                                high: parseFloat(k[2]),
                                low: parseFloat(k[3]),
                                close: parseFloat(k[4]),
                                volume: parseFloat(k[5])
                            }));
                            
                            // å¿«é€ŸæŠ€æœ¯åˆ†æï¼ˆåŒ…å«æ­¢ç›ˆæ­¢æŸï¼‰
                            const analysis = quickAnalyze(klines);
                            
                            if (analysis.signal !== 'neutral') {
                                const currentPrice = klines[klines.length - 1].close;
                                
                                opportunities.push({
                                    symbol,
                                    signal: analysis.signal,
                                    confidence: analysis.confidence,
                                    price: currentPrice,
                                    reasons: analysis.reasons,
                                    score: analysis.score,
                                    timeframe: tf.name,
                                    stopLoss: analysis.stopLoss,
                                    takeProfit: analysis.takeProfit,
                                    riskRewardRatio: analysis.riskRewardRatio
                                });
                            }
                        } catch (error) {
                            console.error(`æ‰«æ${symbol}çš„${tf.name}å‘¨æœŸå¤±è´¥:`, error);
                        }
                    }
                    
                    // æ§åˆ¶è¯·æ±‚é€Ÿåº¦ï¼Œé¿å…è¢«é™æµ
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                } catch (error) {
                    console.error(`æ‰«æ${symbol}å¤±è´¥:`, error);
                }
            }
            
            // éšè—è¿›åº¦ï¼Œæ˜¾ç¤ºç»“æœ
            document.getElementById('scanProgress').style.display = 'none';
            displayScanResults(opportunities);
        }
        
        function quickAnalyze(klines) {
            const closes = klines.map(k => k.close);
            const highs = klines.map(k => k.high);
            const lows = klines.map(k => k.low);
            const volumes = klines.map(k => k.volume);
            const currentPrice = closes[closes.length - 1];
            
            let buySignals = 0;
            let sellSignals = 0;
            const reasons = [];
            
            // 1. RSIåˆ†æï¼ˆå¸åœˆæ ‡å‡†ï¼šè¶…ä¹°>80ï¼Œè¶…å–<20ï¼‰
            const rsi = calculateRSI(closes);
            if (rsi && rsi < 20) {
                buySignals += 2;
                reasons.push('RSIè¶…å–');
            } else if (rsi && rsi > 80) {
                sellSignals += 2;
                reasons.push('RSIè¶…ä¹°');
            }
            
            // 2. MAåˆ†æï¼ˆä½¿ç”¨7ã€30ã€60å‡çº¿ï¼‰
            const ma = calculateMA(closes);
            if (ma && ma.MA7 && ma.MA30) {
                if (currentPrice > ma.MA7 && ma.MA7 > ma.MA30) {
                    buySignals += 1;
                    reasons.push('å‡çº¿å¤šå¤´æ’åˆ—');
                } else if (currentPrice < ma.MA7 && ma.MA7 < ma.MA30) {
                    sellSignals += 1;
                    reasons.push('å‡çº¿ç©ºå¤´æ’åˆ—');
                }
            }
            
            // 3. MACDåˆ†æ
            const macd = calculateMACD(closes);
            if (macd && macd.DIF > 0) {
                buySignals += 1;
                reasons.push('MACDé‡‘å‰');
            } else if (macd && macd.DIF < 0) {
                sellSignals += 1;
                reasons.push('MACDæ­»å‰');
            }
            
            // 4. æˆäº¤é‡åˆ†æ
            const vol = calculateVOL(volumes);
            if (vol && vol.signal === 'buy') {
                buySignals += 1;
                reasons.push('æ”¾é‡ä¸Šæ¶¨');
            } else if (vol && vol.signal === 'sell') {
                sellSignals += 1;
                reasons.push('æ”¾é‡ä¸‹è·Œ');
            }
            
            // 5. å¸ƒæ—å¸¦åˆ†æ
            const boll = calculateBOLL(closes);
            if (boll) {
                if (currentPrice < boll.LOWER) {
                    buySignals += 2;
                    reasons.push('è·Œç ´å¸ƒæ—ä¸‹è½¨');
                } else if (currentPrice > boll.UPPER) {
                    sellSignals += 2;
                    reasons.push('çªç ´å¸ƒæ—ä¸Šè½¨');
                }
            }
            
            // åˆ¤æ–­ä¿¡å·
            let signal = 'neutral';
            let confidence = 0;
            let score = 0;
            let stopLoss = 0;
            let takeProfit = 0;
            let riskRewardRatio = 0;
            
            if (buySignals >= 4) {
                signal = 'buy';
                confidence = Math.min(buySignals * 15, 100);
                score = buySignals;
                
                // è®¡ç®—ä¹°å…¥çš„æ­¢ç›ˆæ­¢æŸ
                // æ­¢æŸï¼šè¿‘æœŸæœ€ä½ç‚¹ä¸‹æ–¹2%ï¼Œæˆ–å½“å‰ä»·ä¸‹æ–¹5%
                const recentLow = Math.min(...lows.slice(-20));
                stopLoss = Math.min(recentLow * 0.98, currentPrice * 0.95);
                
                // æ­¢ç›ˆï¼šæ ¹æ®å¸ƒæ—å¸¦ä¸Šè½¨æˆ–è¿‘æœŸé«˜ç‚¹ï¼Œæˆ–å›ºå®š8%
                const recentHigh = Math.max(...highs.slice(-20));
                if (boll && boll.UPPER > currentPrice) {
                    takeProfit = Math.min(boll.UPPER * 1.02, currentPrice * 1.08);
                } else {
                    takeProfit = Math.max(recentHigh * 0.98, currentPrice * 1.08);
                }
                
                // è®¡ç®—é£é™©æ”¶ç›Šæ¯”
                const risk = currentPrice - stopLoss;
                const reward = takeProfit - currentPrice;
                riskRewardRatio = risk > 0 ? (reward / risk) : 0;
                
            } else if (sellSignals >= 4) {
                signal = 'sell';
                confidence = Math.min(sellSignals * 15, 100);
                score = sellSignals;
                
                // è®¡ç®—å–å‡ºçš„æ­¢ç›ˆæ­¢æŸ
                // æ­¢æŸï¼šè¿‘æœŸæœ€é«˜ç‚¹ä¸Šæ–¹2%ï¼Œæˆ–å½“å‰ä»·ä¸Šæ–¹5%
                const recentHigh = Math.max(...highs.slice(-20));
                stopLoss = Math.max(recentHigh * 1.02, currentPrice * 1.05);
                
                // æ­¢ç›ˆï¼šæ ¹æ®å¸ƒæ—å¸¦ä¸‹è½¨æˆ–è¿‘æœŸä½ç‚¹ï¼Œæˆ–å›ºå®š8%
                const recentLow = Math.min(...lows.slice(-20));
                if (boll && boll.LOWER < currentPrice) {
                    takeProfit = Math.max(boll.LOWER * 0.98, currentPrice * 0.92);
                } else {
                    takeProfit = Math.min(recentLow * 1.02, currentPrice * 0.92);
                }
                
                // è®¡ç®—é£é™©æ”¶ç›Šæ¯”
                const risk = stopLoss - currentPrice;
                const reward = currentPrice - takeProfit;
                riskRewardRatio = risk > 0 ? (reward / risk) : 0;
            }
            
            return {
                signal,
                confidence,
                reasons: reasons.slice(0, 3).join(', '),
                score,
                stopLoss,
                takeProfit,
                riskRewardRatio
            };
        }
        
        function displayScanResults(opportunities) {
            const resultsDiv = document.getElementById('scanResults');
            
            if (opportunities.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ğŸ”</div>
                        <div style="font-size: 18px; color: var(--text-primary); margin-bottom: 8px;">æœªå‘ç°æ˜æ˜¾äº¤æ˜“æœºä¼š</div>
                        <div style="font-size: 14px; color: var(--text-secondary);">å½“å‰å¸‚åœºä¿¡å·ä¸æ˜ç¡®ï¼Œå»ºè®®ç»§ç»­è§‚æœ›</div>
                    </div>
                `;
                return;
            }
            
            // æŒ‰è¯„åˆ†æ’åº
            opportunities.sort((a, b) => b.score - a.score);
            
            // åˆ†ç±»
            const buyOpportunities = opportunities.filter(o => o.signal === 'buy');
            const sellOpportunities = opportunities.filter(o => o.signal === 'sell');
            
            let html = `
                <div style="padding: 20px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 20px;">
                    <div style="font-size: 18px; font-weight: bold; color: var(--text-primary); margin-bottom: 12px;">
                        ğŸ“Š æ‰«æç»“æœæ¦‚è§ˆ
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                        <div style="text-align: center; padding: 16px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div style="font-size: 32px; font-weight: bold; color: var(--green);">${buyOpportunities.length}</div>
                            <div style="font-size: 14px; color: var(--text-secondary);">ä¹°å…¥æœºä¼š</div>
                        </div>
                        <div style="text-align: center; padding: 16px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div style="font-size: 32px; font-weight: bold; color: var(--red);">${sellOpportunities.length}</div>
                            <div style="font-size: 14px; color: var(--text-secondary);">å–å‡ºæœºä¼š</div>
                        </div>
                        <div style="text-align: center; padding: 16px; background: var(--bg-tertiary); border-radius: 6px;">
                            <div style="font-size: 32px; font-weight: bold; color: var(--accent);">${opportunities.length}</div>
                            <div style="font-size: 14px; color: var(--text-secondary);">æ€»æœºä¼šæ•°</div>
                        </div>
                    </div>
                </div>
            `;
            
            if (buyOpportunities.length > 0) {
                html += `
                    <div style="margin-bottom: 24px;">
                        <div style="font-size: 18px; font-weight: bold; color: var(--green); margin-bottom: 16px;">
                            ğŸŸ¢ ä¹°å…¥æœºä¼š (${buyOpportunities.length})
                        </div>
                        <div class="scan-grid">
                            ${buyOpportunities.map(opp => `
                                <div class="scan-item buy-signal" onclick="selectCoinFromScan('${opp.symbol}')">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <div class="scan-symbol">${opp.symbol}</div>
                                        <span style="padding: 4px 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px; color: var(--text-secondary);">
                                            ${opp.timeframe}
                                        </span>
                                    </div>
                                    <span class="scan-signal buy">ä¹°å…¥ä¿¡å·</span>
                                    <div style="font-size: 20px; font-weight: bold; color: var(--text-primary); margin: 8px 0;">
                                        $${formatPrice(opp.price)}
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <span style="font-size: 12px; color: var(--text-secondary);">å¯ä¿¡åº¦:</span>
                                        <span style="font-size: 14px; font-weight: 600; color: var(--green);">${opp.confidence}%</span>
                                        <span style="margin-left: 8px; font-size: 12px; color: var(--text-secondary);">é£é™©æ¯”:</span>
                                        <span style="font-size: 14px; font-weight: 600; color: ${opp.riskRewardRatio >= 2 ? 'var(--green)' : 'var(--yellow)'};">1:${opp.riskRewardRatio.toFixed(2)}</span>
                                    </div>
                                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                            <span style="font-size: 11px; color: var(--text-secondary);">æ­¢ç›ˆ:</span>
                                            <span style="font-size: 13px; font-weight: 600; color: var(--green);">$${formatPrice(opp.takeProfit)}</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between;">
                                            <span style="font-size: 11px; color: var(--text-secondary);">æ­¢æŸ:</span>
                                            <span style="font-size: 13px; font-weight: 600; color: var(--red);">$${formatPrice(opp.stopLoss)}</span>
                                        </div>
                                    </div>
                                    <div class="scan-details">
                                        ${opp.reasons}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (sellOpportunities.length > 0) {
                html += `
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--red); margin-bottom: 16px;">
                            ğŸ”´ å–å‡ºæœºä¼š (${sellOpportunities.length})
                        </div>
                        <div class="scan-grid">
                            ${sellOpportunities.map(opp => `
                                <div class="scan-item sell-signal" onclick="selectCoinFromScan('${opp.symbol}')">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <div class="scan-symbol">${opp.symbol}</div>
                                        <span style="padding: 4px 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px; color: var(--text-secondary);">
                                            ${opp.timeframe}
                                        </span>
                                    </div>
                                    <span class="scan-signal sell">å–å‡ºä¿¡å·</span>
                                    <div style="font-size: 20px; font-weight: bold; color: var(--text-primary); margin: 8px 0;">
                                        $${formatPrice(opp.price)}
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <span style="font-size: 12px; color: var(--text-secondary);">å¯ä¿¡åº¦:</span>
                                        <span style="font-size: 14px; font-weight: 600; color: var(--red);">${opp.confidence}%</span>
                                        <span style="margin-left: 8px; font-size: 12px; color: var(--text-secondary);">é£é™©æ¯”:</span>
                                        <span style="font-size: 14px; font-weight: 600; color: ${opp.riskRewardRatio >= 2 ? 'var(--green)' : 'var(--yellow)'};">1:${opp.riskRewardRatio.toFixed(2)}</span>
                                    </div>
                                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                            <span style="font-size: 11px; color: var(--text-secondary);">æ­¢ç›ˆ:</span>
                                            <span style="font-size: 13px; font-weight: 600; color: var(--green);">$${formatPrice(opp.takeProfit)}</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between;">
                                            <span style="font-size: 11px; color: var(--text-secondary);">æ­¢æŸ:</span>
                                            <span style="font-size: 13px; font-weight: 600; color: var(--red);">$${formatPrice(opp.stopLoss)}</span>
                                        </div>
                                    </div>
                                    <div class="scan-details">
                                        ${opp.reasons}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = html;
        }
        
        function selectCoinFromScan(fullSymbol) {
            closeScanModal();
            
            // ä»å®Œæ•´ç¬¦å·æå–çŸ­ç¬¦å·ï¼ˆå¦‚ BTCUSDT -> BTCï¼‰
            let shortSymbol = fullSymbol.replace('USDT', '').replace('BTC', '').replace('ETH', '');
            
            // å¦‚æœå¸ç§ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œå…ˆæ·»åŠ 
            if (!SYMBOLS.includes(shortSymbol)) {
                SYMBOLS.push(shortSymbol);
                SYMBOL_MAP[shortSymbol] = fullSymbol;
                
                // é‡æ–°è¿æ¥WebSocket
                if (ws) {
                    ws.close();
                }
                connectWebSocket();
                
                updateCoinList();
                loadKlineData(shortSymbol, currentTimeframe);
            }
            
            // é€‰æ‹©å¸ç§
            selectCoin(shortSymbol);
        }
        
        function closeScanModal() {
            document.getElementById('scanModal').style.display = 'none';
        }

        // ==================== æ§åˆ¶åŠŸèƒ½ ====================
        function toggleMode() {
            realtimeMode = !realtimeMode;
            const btn = document.getElementById('toggleBtn');
            
            if (realtimeMode) {
                btn.innerHTML = 'â¸ï¸ <span>æš‚åœ</span>';
                btn.className = 'btn btn-success';
                if (!isConnected) connectWebSocket();
            } else {
                btn.innerHTML = 'â–¶ï¸ <span>æ¢å¤</span>';
                btn.className = 'btn btn-secondary';
                if (ws) ws.close();
            }
            
            updateStatus(isConnected);
        }

        // ä¾§è¾¹æ æ§åˆ¶å‡½æ•°
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            
            if (sidebar.classList.contains('show')) {
                closeSidebar();
            } else {
                sidebar.classList.add('show');
                overlay.classList.add('show');
                // åœ¨ç§»åŠ¨ç«¯é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
                if (window.innerWidth <= 1024) {
                    document.body.style.overflow = 'hidden';
                }
            }
        }

        function closeSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            
            sidebar.classList.remove('show');
            overlay.classList.remove('show');
            // æ¢å¤æ»šåŠ¨
            document.body.style.overflow = '';
        }

        function manualRefresh() {
            SYMBOLS.forEach(symbol => {
                loadKlineData(symbol, currentTimeframe);
            });
            
            if (currentSymbol) {
                selectCoin(currentSymbol);
            }
        }

        function changeTimeframe(timeframe, event) {
            currentTimeframe = timeframe;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // æ¸…ç©ºä¹‹å‰çš„åˆ†ææ•°æ®ï¼ˆåˆ‡æ¢å‘¨æœŸæ—¶ï¼‰
            clearAnalysisResults();
            
            if (currentSymbol) {
                loadKlineData(currentSymbol, timeframe);
            }
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function formatPrice(price) {
            if (price < 0.0001) return price.toFixed(8);
            if (price < 0.01) return price.toFixed(6);
            if (price < 1) return price.toFixed(4);
            if (price < 100) return price.toFixed(3);
            return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        // ==================== åˆå§‹åŒ– ====================
        window.onload = () => {
            console.log('åŠ å¯†è´§å¸æ™ºèƒ½ç›‘æµ‹ç³»ç»Ÿå¯åŠ¨');
            connectWebSocket();
            
            // åˆå§‹åŒ–å¸ç§åˆ—è¡¨
            updateCoinList();
            
            // é€‰æ‹©ç¬¬ä¸€ä¸ªå¸ç§
            if (SYMBOLS.length > 0) {
                selectCoin(SYMBOLS[0]);
            }
            
            // å®šæœŸåˆ·æ–°Kçº¿å›¾ï¼ˆä½œä¸ºWebSocketæ›´æ–°çš„å¤‡ä»½ï¼‰
            setInterval(() => {
                if (realtimeMode && currentSymbol && klineData[currentSymbol]) {
                    drawChart(klineData[currentSymbol]);
                }
            }, 2000); // 2ç§’åˆ·æ–°ä¸€æ¬¡ï¼Œä¿è¯å®æ—¶æ€§
        };

        window.onbeforeunload = () => {
            if (ws) ws.close();
        };
    </script>
</body>
</html>

